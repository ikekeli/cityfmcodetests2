{"version":3,"sources":["js\\element-internals-polyfill.js"],"names":["refMap","WeakMap","validityMap","hiddenInputMap","internalsMap","validationMessageMap","formsMap","shadowHostsMap","formElementsMap","refValueMap","upgradeMap","shadowRootMap","validationAnchorMap","documentFragmentMap","connectedCallbackMap","validityUpgradeMap","aom","ariaAtomic","ariaAutoComplete","ariaBusy","ariaChecked","ariaColCount","ariaColIndex","ariaColIndexText","ariaColSpan","ariaCurrent","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaInvalid","ariaKeyShortcuts","ariaLabel","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowIndexText","ariaRowSpan","ariaSelected","ariaSetSize","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","role","initNode","node","internals","get","form","initForm","initLabels","labels","walkFieldset","firstRender","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","has","FILTER_ACCEPT","FILTER_SKIP","current","nextNode","isCallNecessary","disabled","formDisabledCallback","setDisabled","disabledObserverConfig","attributes","attributeFilter","disabledObserver","MutationObserver","mutationsList","mutation","target","constructor","hasAttribute","localName","observerCallback","mutationList","forEach","mutationRecord","addedNodes","removedNodes","added","Array","from","removed","Object","keys","filter","key","setAttribute","delete","validity","valid","toString","formElements","observe","removeHiddenInputs","disconnect","fragmentObserverCallback","observer","upgradeInternals","observerConfig","childList","subtree","ref","toggleAttribute","removeAttribute","apply","hiddenInput","remove","set","createHiddenInput","input","createElement","type","name","getAttribute","after","push","length","label","addEventListener","click","bind","firstLabelId","id","htmlFor","setFormValidity","nativeControlValidity","elements","element","tagName","includes","map","polyfilledElements","hasInvalid","control","isConnected","formInputCallback","event","findParentForm","formChangeCallback","formResetCallback","size","formAssociated","add","initSet","Set","SUBMIT_BUTTON_SELECTOR","submitButtonSelector","closest","noValidate","reverse","reportValidity","preventDefault","wireSubmitLogic","formAssociatedCallback","setTimeout","elem","parent","parentNode","throwIfNotFormAssociated","message","ErrorType","DOMException","overrideFormMethod","returnValue","method","ValidityState","this","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","seal","isValid","validityState","customStateMap","CustomStateSet","isPolyfilled","super","indexOf","TypeError","state","test","result","part","clear","entry","entries","__classPrivateFieldGet","receiver","kind","f","call","value","_HTMLFormControlsCollection_elements","HTMLFormControlsCollection","__classPrivateFieldSet","i","freeze","Symbol","iterator","item","namedItem","ElementInternals","rootNode","getRootNode","states","closureValue","attributeName","defineProperty","initAom","initRef","DocumentFragment","fragment","deferUpgrade","checkValidity","willValidate","validityEvent","Event","bubbles","cancelable","composed","dispatchEvent","hostRoot","querySelectorAll","anchor","focus","setFormValue","FormData","formDataKey","formDataValue","setValidity","validityChanges","validationMessage","validityChangesObj","validityObject","check","newState","reconcileValidity","shadowRoot","window","HTMLElement","prototype","attachInternals","ElementInternalsFeatureDetection","randomName","Math","random","replace","customElements","define","featureDetectionElement","every","prop","isElementInternalsSupported","args","CustomElementRegistry","attachShadowObserver","attachShadow","ShadyDOM","options","connectedCallback","Error","Element","documentElement","HTMLFormElement","getOwnPropertyDescriptor","orderedElements","concat","sort","a","b","compareDocumentPosition","patchFormPrototype"],"mappings":"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","sourcesContent":["(function () {\n    'use strict';\n\n    const refMap = new WeakMap();\n    const validityMap = new WeakMap();\n    const hiddenInputMap = new WeakMap();\n    const internalsMap = new WeakMap();\n    const validationMessageMap = new WeakMap();\n    const formsMap = new WeakMap();\n    const shadowHostsMap = new WeakMap();\n    const formElementsMap = new WeakMap();\n    const refValueMap = new WeakMap();\n    const upgradeMap = new WeakMap();\n    const shadowRootMap = new WeakMap();\n    const validationAnchorMap = new WeakMap();\n    const documentFragmentMap = new WeakMap();\n    const connectedCallbackMap = new WeakMap();\n    const validityUpgradeMap = new WeakMap();\n\n    const aom = {\n        ariaAtomic: 'aria-atomic',\n        ariaAutoComplete: 'aria-autocomplete',\n        ariaBusy: 'aria-busy',\n        ariaChecked: 'aria-checked',\n        ariaColCount: 'aria-colcount',\n        ariaColIndex: 'aria-colindex',\n        ariaColIndexText: 'aria-colindextext',\n        ariaColSpan: 'aria-colspan',\n        ariaCurrent: 'aria-current',\n        ariaDisabled: 'aria-disabled',\n        ariaExpanded: 'aria-expanded',\n        ariaHasPopup: 'aria-haspopup',\n        ariaHidden: 'aria-hidden',\n        ariaInvalid: 'aria-invalid',\n        ariaKeyShortcuts: 'aria-keyshortcuts',\n        ariaLabel: 'aria-label',\n        ariaLevel: 'aria-level',\n        ariaLive: 'aria-live',\n        ariaModal: 'aria-modal',\n        ariaMultiLine: 'aria-multiline',\n        ariaMultiSelectable: 'aria-multiselectable',\n        ariaOrientation: 'aria-orientation',\n        ariaPlaceholder: 'aria-placeholder',\n        ariaPosInSet: 'aria-posinset',\n        ariaPressed: 'aria-pressed',\n        ariaReadOnly: 'aria-readonly',\n        ariaRelevant: 'aria-relevant',\n        ariaRequired: 'aria-required',\n        ariaRoleDescription: 'aria-roledescription',\n        ariaRowCount: 'aria-rowcount',\n        ariaRowIndex: 'aria-rowindex',\n        ariaRowIndexText: 'aria-rowindextext',\n        ariaRowSpan: 'aria-rowspan',\n        ariaSelected: 'aria-selected',\n        ariaSetSize: 'aria-setsize',\n        ariaSort: 'aria-sort',\n        ariaValueMax: 'aria-valuemax',\n        ariaValueMin: 'aria-valuemin',\n        ariaValueNow: 'aria-valuenow',\n        ariaValueText: 'aria-valuetext',\n        role: 'role'\n    };\n    const initAom = (ref, internals) => {\n        for (let key in aom) {\n            internals[key] = null;\n            let closureValue = null;\n            const attributeName = aom[key];\n            Object.defineProperty(internals, key, {\n                get() {\n                    return closureValue;\n                },\n                set(value) {\n                    closureValue = value;\n                    if (ref.isConnected) {\n                        ref.setAttribute(attributeName, value);\n                    }\n                    else {\n                        upgradeMap.set(ref, internals);\n                    }\n                }\n            });\n        }\n    };\n\n    function initNode(node) {\n        const internals = internalsMap.get(node);\n        const { form } = internals;\n        initForm(node, form, internals);\n        initLabels(node, internals.labels);\n    }\n    const walkFieldset = (node, firstRender = false) => {\n        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {\n            acceptNode(node) {\n                return internalsMap.has(node) ?\n                    NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n            }\n        });\n        let current = walker.nextNode();\n        const isCallNecessary = (!firstRender || node.disabled);\n        while (current) {\n            if (current.formDisabledCallback && isCallNecessary) {\n                setDisabled(current, node.disabled);\n            }\n            current = walker.nextNode();\n        }\n    };\n    const disabledObserverConfig = { attributes: true, attributeFilter: ['disabled'] };\n    const disabledObserver = new MutationObserver((mutationsList) => {\n        for (const mutation of mutationsList) {\n            const target = mutation.target;\n            if (target.constructor['formAssociated']) {\n                setDisabled(target, target.hasAttribute('disabled'));\n            }\n            else if (target.localName === 'fieldset') {\n                walkFieldset(target);\n            }\n        }\n    });\n    function observerCallback(mutationList) {\n        mutationList.forEach(mutationRecord => {\n            const { addedNodes, removedNodes } = mutationRecord;\n            const added = Array.from(addedNodes);\n            const removed = Array.from(removedNodes);\n            added.forEach(node => {\n                if (internalsMap.has(node) && node.constructor['formAssociated']) {\n                    initNode(node);\n                }\n                if (upgradeMap.has(node)) {\n                    const internals = upgradeMap.get(node);\n                    const aomKeys = Object.keys(aom);\n                    aomKeys\n                        .filter(key => internals[key] !== null)\n                        .forEach(key => {\n                        node.setAttribute(aom[key], internals[key]);\n                    });\n                    upgradeMap.delete(node);\n                }\n                if (validityUpgradeMap.has(node)) {\n                    const internals = validityUpgradeMap.get(node);\n                    node.setAttribute('internals-valid', internals.validity.valid.toString());\n                    node.setAttribute('internals-invalid', (!internals.validity.valid).toString());\n                    node.setAttribute('aria-invalid', (!internals.validity.valid).toString());\n                    validityUpgradeMap.delete(node);\n                }\n                if (node.localName === 'form') {\n                    const formElements = formElementsMap.get(node);\n                    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, {\n                        acceptNode(node) {\n                            return internalsMap.has(node) && !(formElements && formElements.has(node)) ?\n                                NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n                        }\n                    });\n                    let current = walker.nextNode();\n                    while (current) {\n                        initNode(current);\n                        current = walker.nextNode();\n                    }\n                }\n                if (node.localName === 'fieldset') {\n                    disabledObserver.observe(node, disabledObserverConfig);\n                    walkFieldset(node, true);\n                }\n            });\n            removed.forEach(node => {\n                const internals = internalsMap.get(node);\n                if (internals && hiddenInputMap.get(internals)) {\n                    removeHiddenInputs(internals);\n                }\n                if (shadowHostsMap.has(node)) {\n                    const observer = shadowHostsMap.get(node);\n                    observer.disconnect();\n                }\n            });\n        });\n    }\n    function fragmentObserverCallback(mutationList) {\n        mutationList.forEach(mutation => {\n            const { removedNodes } = mutation;\n            removedNodes.forEach(node => {\n                const observer = documentFragmentMap.get(mutation.target);\n                if (internalsMap.has(node)) {\n                    upgradeInternals(node);\n                }\n                observer.disconnect();\n            });\n        });\n    }\n    const deferUpgrade = (fragment) => {\n        const observer = new MutationObserver(fragmentObserverCallback);\n        observer.observe(fragment, { childList: true });\n        documentFragmentMap.set(fragment, observer);\n    };\n    new MutationObserver(observerCallback);\n    const observerConfig = {\n        childList: true,\n        subtree: true\n    };\n\n    const setDisabled = (ref, disabled) => {\n        ref.toggleAttribute('internals-disabled', disabled);\n        if (disabled) {\n            ref.setAttribute('aria-disabled', 'true');\n        }\n        else {\n            ref.removeAttribute('aria-disabled');\n        }\n        if (ref.formDisabledCallback) {\n            ref.formDisabledCallback.apply(ref, [disabled]);\n        }\n    };\n    const removeHiddenInputs = (internals) => {\n        const hiddenInputs = hiddenInputMap.get(internals);\n        hiddenInputs.forEach(hiddenInput => {\n            hiddenInput.remove();\n        });\n        hiddenInputMap.set(internals, []);\n    };\n    const createHiddenInput = (ref, internals) => {\n        const input = document.createElement('input');\n        input.type = 'hidden';\n        input.name = ref.getAttribute('name');\n        ref.after(input);\n        hiddenInputMap.get(internals).push(input);\n        return input;\n    };\n    const initRef = (ref, internals) => {\n        hiddenInputMap.set(internals, []);\n        disabledObserver.observe(ref, disabledObserverConfig);\n    };\n    const initLabels = (ref, labels) => {\n        if (labels.length) {\n            Array.from(labels).forEach(label => label.addEventListener('click', ref.click.bind(ref)));\n            let firstLabelId = labels[0].id;\n            if (!labels[0].id) {\n                firstLabelId = `${labels[0].htmlFor}_Label`;\n                labels[0].id = firstLabelId;\n            }\n            ref.setAttribute('aria-labelledby', firstLabelId);\n        }\n    };\n    const setFormValidity = (form) => {\n        const nativeControlValidity = Array.from(form.elements)\n            .filter((element) => !element.tagName.includes('-') && element.validity)\n            .map((element) => element.validity.valid);\n        const polyfilledElements = formElementsMap.get(form) || [];\n        const polyfilledValidity = Array.from(polyfilledElements)\n            .filter(control => control.isConnected)\n            .map((control) => internalsMap.get(control).validity.valid);\n        const hasInvalid = [...nativeControlValidity, ...polyfilledValidity].includes(false);\n        form.toggleAttribute('internals-invalid', hasInvalid);\n        form.toggleAttribute('internals-valid', !hasInvalid);\n    };\n    const formInputCallback = (event) => {\n        setFormValidity(findParentForm(event.target));\n    };\n    const formChangeCallback = (event) => {\n        setFormValidity(findParentForm(event.target));\n    };\n    const wireSubmitLogic = (form) => {\n        const SUBMIT_BUTTON_SELECTOR = ':is(:is(button, input)[type=submit], button:not([type])):not([disabled])';\n        let submitButtonSelector = `${SUBMIT_BUTTON_SELECTOR}:not([form])`;\n        if (form.id) {\n            submitButtonSelector += `,${SUBMIT_BUTTON_SELECTOR}[form='${form.id}']`;\n        }\n        form.addEventListener('click', event => {\n            const target = event.target;\n            if (target.closest(submitButtonSelector)) {\n                const elements = formElementsMap.get(form);\n                if (form.noValidate) {\n                    return;\n                }\n                if (elements.size) {\n                    const nodes = Array.from(elements);\n                    const validityList = nodes\n                        .reverse()\n                        .map(node => {\n                        const internals = internalsMap.get(node);\n                        return internals.reportValidity();\n                    });\n                    if (validityList.includes(false)) {\n                        event.preventDefault();\n                    }\n                }\n            }\n        });\n    };\n    const formResetCallback = (event) => {\n        const elements = formElementsMap.get(event.target);\n        if (elements && elements.size) {\n            elements.forEach(element => {\n                if (element.constructor.formAssociated && element.formResetCallback) {\n                    element.formResetCallback.apply(element);\n                }\n            });\n        }\n    };\n    const initForm = (ref, form, internals) => {\n        if (form) {\n            const formElements = formElementsMap.get(form);\n            if (formElements) {\n                formElements.add(ref);\n            }\n            else {\n                const initSet = new Set();\n                initSet.add(ref);\n                formElementsMap.set(form, initSet);\n                wireSubmitLogic(form);\n                form.addEventListener('reset', formResetCallback);\n                form.addEventListener('input', formInputCallback);\n                form.addEventListener('change', formChangeCallback);\n            }\n            formsMap.set(form, { ref, internals });\n            if (ref.constructor['formAssociated'] && ref.formAssociatedCallback) {\n                setTimeout(() => {\n                    ref.formAssociatedCallback.apply(ref, [form]);\n                }, 0);\n            }\n            setFormValidity(form);\n        }\n    };\n    const findParentForm = (elem) => {\n        let parent = elem.parentNode;\n        if (parent && parent.tagName !== 'FORM') {\n            parent = findParentForm(parent);\n        }\n        return parent;\n    };\n    const throwIfNotFormAssociated = (ref, message, ErrorType = DOMException) => {\n        if (!ref.constructor['formAssociated']) {\n            throw new ErrorType(message);\n        }\n    };\n    const overrideFormMethod = (form, returnValue, method) => {\n        const elements = formElementsMap.get(form);\n        if (elements && elements.size) {\n            elements.forEach(element => {\n                const internals = internalsMap.get(element);\n                const valid = internals[method]();\n                if (!valid) {\n                    returnValue = false;\n                }\n            });\n        }\n        return returnValue;\n    };\n    const upgradeInternals = (ref) => {\n        if (ref.constructor['formAssociated']) {\n            const internals = internalsMap.get(ref);\n            const { labels, form } = internals;\n            initLabels(ref, labels);\n            initForm(ref, form, internals);\n        }\n    };\n\n    class ValidityState {\n        constructor() {\n            this.badInput = false;\n            this.customError = false;\n            this.patternMismatch = false;\n            this.rangeOverflow = false;\n            this.rangeUnderflow = false;\n            this.stepMismatch = false;\n            this.tooLong = false;\n            this.tooShort = false;\n            this.typeMismatch = false;\n            this.valid = true;\n            this.valueMissing = false;\n            Object.seal(this);\n        }\n    }\n    const setValid = (validityObject) => {\n        validityObject.badInput = false;\n        validityObject.customError = false;\n        validityObject.patternMismatch = false;\n        validityObject.rangeOverflow = false;\n        validityObject.rangeUnderflow = false;\n        validityObject.stepMismatch = false;\n        validityObject.tooLong = false;\n        validityObject.tooShort = false;\n        validityObject.typeMismatch = false;\n        validityObject.valid = true;\n        validityObject.valueMissing = false;\n        return validityObject;\n    };\n    const reconcileValidity = (validityObject, newState, form) => {\n        validityObject.valid = isValid(newState);\n        Object.keys(newState).forEach(key => validityObject[key] = newState[key]);\n        if (form) {\n            setFormValidity(form);\n        }\n        return validityObject;\n    };\n    const isValid = (validityState) => {\n        let valid = true;\n        for (let key in validityState) {\n            if (key !== 'valid' && validityState[key] !== false) {\n                valid = false;\n            }\n        }\n        return valid;\n    };\n\n    const customStateMap = new WeakMap();\n    class CustomStateSet extends Set {\n        static get isPolyfilled() {\n            return true;\n        }\n        constructor(ref) {\n            super();\n            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n                throw new TypeError('Illegal constructor');\n            }\n            customStateMap.set(this, ref);\n        }\n        add(state) {\n            if (!/^--/.test(state) || typeof state !== 'string') {\n                throw new DOMException(`Failed to execute 'add' on 'CustomStateSet': The specified value ${state} must start with '--'.`);\n            }\n            const result = super.add(state);\n            const ref = customStateMap.get(this);\n            ref.toggleAttribute(`state${state}`, true);\n            if (ref.part) {\n                ref.part.add(`state${state}`);\n            }\n            return result;\n        }\n        clear() {\n            for (let [entry] of this.entries()) {\n                this.delete(entry);\n            }\n            super.clear();\n        }\n        delete(state) {\n            const result = super.delete(state);\n            const ref = customStateMap.get(this);\n            ref.toggleAttribute(`state${state}`, false);\n            if (ref.part) {\n                ref.part.remove(`state${state}`);\n            }\n            return result;\n        }\n    }\n\n    function __classPrivateFieldGet(receiver, state, kind, f) {\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n    }\n    function __classPrivateFieldSet(receiver, state, value, kind, f) {\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n    }\n\n    var _HTMLFormControlsCollection_elements;\n    class HTMLFormControlsCollection {\n        constructor(elements) {\n            _HTMLFormControlsCollection_elements.set(this, void 0);\n            __classPrivateFieldSet(this, _HTMLFormControlsCollection_elements, elements, \"f\");\n            for (let i = 0; i < elements.length; i++) {\n                let element = elements[i];\n                this[i] = element;\n                if (element.hasAttribute('name')) {\n                    this[element.getAttribute('name')] = element;\n                }\n            }\n            Object.freeze(this);\n        }\n        get length() {\n            return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, \"f\").length;\n        }\n        [(_HTMLFormControlsCollection_elements = new WeakMap(), Symbol.iterator)]() {\n            return __classPrivateFieldGet(this, _HTMLFormControlsCollection_elements, \"f\")[Symbol.iterator]();\n        }\n        item(i) {\n            return this[i] == null ? null : this[i];\n        }\n        namedItem(name) {\n            return this[name] == null ? null : this[name];\n        }\n    }\n\n    function patchFormPrototype() {\n        const checkValidity = HTMLFormElement.prototype.checkValidity;\n        HTMLFormElement.prototype.checkValidity = checkValidityOverride;\n        const reportValidity = HTMLFormElement.prototype.reportValidity;\n        HTMLFormElement.prototype.reportValidity = reportValidityOverride;\n        function checkValidityOverride(...args) {\n            let returnValue = checkValidity.apply(this, args);\n            return overrideFormMethod(this, returnValue, 'checkValidity');\n        }\n        function reportValidityOverride(...args) {\n            let returnValue = reportValidity.apply(this, args);\n            return overrideFormMethod(this, returnValue, 'reportValidity');\n        }\n        const { get } = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'elements');\n        Object.defineProperty(HTMLFormElement.prototype, 'elements', {\n            get(...args) {\n                const elements = get.call(this, ...args);\n                const polyfilledElements = Array.from(formElementsMap.get(this) || []);\n                if (polyfilledElements.length === 0) {\n                    return elements;\n                }\n                const orderedElements = Array.from(elements).concat(polyfilledElements).sort((a, b) => {\n                    if (a.compareDocumentPosition) {\n                        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n                    }\n                    return 0;\n                });\n                return new HTMLFormControlsCollection(orderedElements);\n            },\n        });\n    }\n\n    class ElementInternals {\n        static get isPolyfilled() {\n            return true;\n        }\n        constructor(ref) {\n            if (!ref || !ref.tagName || ref.tagName.indexOf('-') === -1) {\n                throw new TypeError('Illegal constructor');\n            }\n            const rootNode = ref.getRootNode();\n            const validity = new ValidityState();\n            this.states = new CustomStateSet(ref);\n            refMap.set(this, ref);\n            validityMap.set(this, validity);\n            internalsMap.set(ref, this);\n            initAom(ref, this);\n            initRef(ref, this);\n            Object.seal(this);\n            upgradeInternals(ref);\n            if (rootNode instanceof DocumentFragment) {\n                deferUpgrade(rootNode);\n            }\n        }\n        checkValidity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'checkValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!this.willValidate) {\n                return true;\n            }\n            const validity = validityMap.get(this);\n            if (!validity.valid) {\n                const validityEvent = new Event('invalid', {\n                    bubbles: false,\n                    cancelable: true,\n                    composed: false\n                });\n                ref.dispatchEvent(validityEvent);\n            }\n            return validity.valid;\n        }\n        get form() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'form' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            let form;\n            if (ref.constructor['formAssociated'] === true) {\n                form = findParentForm(ref);\n            }\n            return form;\n        }\n        get labels() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'labels' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            const id = ref.getAttribute('id');\n            const hostRoot = ref.getRootNode();\n            if (hostRoot && id) {\n                return hostRoot.querySelectorAll(`[for=\"${id}\"]`);\n            }\n            return [];\n        }\n        reportValidity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!this.willValidate) {\n                return true;\n            }\n            const valid = this.checkValidity();\n            const anchor = validationAnchorMap.get(this);\n            if (anchor && !ref.constructor['formAssociated']) {\n                throw new DOMException(`Failed to execute 'reportValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            }\n            if (!valid && anchor) {\n                ref.focus();\n                anchor.focus();\n            }\n            return valid;\n        }\n        setFormValue(value) {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'setFormValue' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            removeHiddenInputs(this);\n            if (value != null && !(value instanceof FormData)) {\n                if (ref.getAttribute('name')) {\n                    const hiddenInput = createHiddenInput(ref, this);\n                    hiddenInput.value = value;\n                }\n            }\n            else if (value != null && value instanceof FormData) {\n                Array.from(value).reverse().forEach(([formDataKey, formDataValue]) => {\n                    if (typeof formDataValue === 'string') {\n                        const hiddenInput = createHiddenInput(ref, this);\n                        hiddenInput.name = formDataKey;\n                        hiddenInput.value = formDataValue;\n                    }\n                });\n            }\n            refValueMap.set(ref, value);\n        }\n        setValidity(validityChanges, validationMessage, anchor) {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to execute 'setValidity' on 'ElementInternals': The target element is not a form-associated custom element.`);\n            if (!validityChanges) {\n                throw new TypeError('Failed to execute \\'setValidity\\' on \\'ElementInternals\\': 1 argument required, but only 0 present.');\n            }\n            validationAnchorMap.set(this, anchor);\n            const validity = validityMap.get(this);\n            const validityChangesObj = {};\n            for (const key in validityChanges) {\n                validityChangesObj[key] = validityChanges[key];\n            }\n            if (Object.keys(validityChangesObj).length === 0) {\n                setValid(validity);\n            }\n            const check = { ...validity, ...validityChangesObj };\n            delete check.valid;\n            const { valid } = reconcileValidity(validity, check, this.form);\n            if (!valid && !validationMessage) {\n                throw new DOMException(`Failed to execute 'setValidity' on 'ElementInternals': The second argument should not be empty if one or more flags in the first argument are true.`);\n            }\n            validationMessageMap.set(this, valid ? '' : validationMessage);\n            if (ref.isConnected) {\n                ref.toggleAttribute('internals-invalid', !valid);\n                ref.toggleAttribute('internals-valid', valid);\n                ref.setAttribute('aria-invalid', `${!valid}`);\n            }\n            else {\n                validityUpgradeMap.set(ref, this);\n            }\n        }\n        get shadowRoot() {\n            const ref = refMap.get(this);\n            const shadowRoot = shadowRootMap.get(ref);\n            if (shadowRoot) {\n                return shadowRoot;\n            }\n            return null;\n        }\n        get validationMessage() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'validationMessage' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            return validationMessageMap.get(this);\n        }\n        get validity() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'validity' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            const validity = validityMap.get(this);\n            return validity;\n        }\n        get willValidate() {\n            const ref = refMap.get(this);\n            throwIfNotFormAssociated(ref, `Failed to read the 'willValidate' property from 'ElementInternals': The target element is not a form-associated custom element.`);\n            if ((ref.disabled || ref.hasAttribute('disabled')) ||\n                ref.hasAttribute('readonly')) {\n                return false;\n            }\n            return true;\n        }\n    }\n    function isElementInternalsSupported() {\n        if (!window.ElementInternals || !HTMLElement.prototype.attachInternals) {\n            return false;\n        }\n        class ElementInternalsFeatureDetection extends HTMLElement {\n            constructor() {\n                super();\n                this.internals = this.attachInternals();\n            }\n        }\n        const randomName = `element-internals-feature-detection-${Math.random().toString(36).replace(/[^a-z]+/g, '')}`;\n        customElements.define(randomName, ElementInternalsFeatureDetection);\n        const featureDetectionElement = new ElementInternalsFeatureDetection();\n        return [\n            'shadowRoot',\n            'form',\n            'willValidate',\n            'validity',\n            'validationMessage',\n            'labels',\n            'setFormValue',\n            'setValidity',\n            'checkValidity',\n            'reportValidity'\n        ].every(prop => prop in featureDetectionElement.internals);\n    }\n    if (!isElementInternalsSupported()) {\n        window.ElementInternals = ElementInternals;\n        const define = CustomElementRegistry.prototype.define;\n        CustomElementRegistry.prototype.define = function (name, constructor, options) {\n            if (constructor.formAssociated) {\n                const connectedCallback = constructor.prototype.connectedCallback;\n                constructor.prototype.connectedCallback = function () {\n                    if (!connectedCallbackMap.has(this)) {\n                        connectedCallbackMap.set(this, true);\n                        if (this.hasAttribute('disabled')) {\n                            setDisabled(this, true);\n                        }\n                    }\n                    if (connectedCallback != null) {\n                        connectedCallback.apply(this);\n                    }\n                };\n            }\n            define.call(this, name, constructor, options);\n        };\n        function attachShadowObserver(...args) {\n            const shadowRoot = attachShadow.apply(this, args);\n            const observer = new MutationObserver(observerCallback);\n            shadowRootMap.set(this, shadowRoot);\n            if (window.ShadyDOM) {\n                observer.observe(this, observerConfig);\n            }\n            else {\n                observer.observe(shadowRoot, observerConfig);\n            }\n            shadowHostsMap.set(this, observer);\n            return shadowRoot;\n        }\n        HTMLElement.prototype.attachInternals = function () {\n            if (!this.tagName) {\n                return {};\n            }\n            else if (this.tagName.indexOf('-') === -1) {\n                throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': Unable to attach ElementInternals to non-custom elements.`);\n            }\n            if (internalsMap.has(this)) {\n                throw new DOMException(`DOMException: Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);\n            }\n            return new ElementInternals(this);\n        };\n        const attachShadow = Element.prototype.attachShadow;\n        Element.prototype.attachShadow = attachShadowObserver;\n        const documentObserver = new MutationObserver(observerCallback);\n        documentObserver.observe(document.documentElement, observerConfig);\n        if (typeof HTMLFormElement !== 'undefined') {\n            patchFormPrototype();\n        }\n        if (!window.CustomStateSet) {\n            window.CustomStateSet = CustomStateSet;\n        }\n    }\n    else if (!window.CustomStateSet) {\n        window.CustomStateSet = CustomStateSet;\n        const attachInternals = HTMLElement.prototype.attachInternals;\n        HTMLElement.prototype.attachInternals = function (...args) {\n            const internals = attachInternals.call(this, args);\n            internals.states = new CustomStateSet(this);\n            return internals;\n        };\n    }\n\n})();\n"]}