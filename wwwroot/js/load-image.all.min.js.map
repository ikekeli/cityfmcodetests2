{"version":3,"sources":["js\\load-image.js","js\\load-image-scale.js","js\\load-image-meta.js","js\\load-image-fetch.js","js\\load-image-orientation.js","js\\load-image-exif.js","js\\load-image-exif-map.js","js\\load-image-iptc.js","js\\load-image-iptc-map.js"],"names":["$","urlAPI","URL","webkitURL","createObjectURL","blob","revokeObjectURL","url","revokeHelper","options","slice","noRevoke","readFile","file","onload","onerror","method","FileReader","reader","call","this","result","onabort","error","readerMethod","isInstanceOf","type","obj","Object","prototype","toString","loadImage","callback","executor","resolve","reject","img","document","createElement","resolveWrapper","data","Error","image","fetchBlobCallback","err","console","log","crossOrigin","src","event","originalWidth","naturalWidth","width","originalHeight","naturalHeight","height","transform","requiresMetaData","fetchBlob","Promise","meta","global","define","amd","module","exports","window","factory","require","originalTransform","createCanvas","offscreen","OffscreenCanvas","canvas","scale","transformCoordinates","getTransformedOptions","newOptions","i","aspectRatio","hasOwnProperty","crop","maxWidth","maxHeight","drawImage","sourceX","sourceY","sourceWidth","sourceHeight","destWidth","destHeight","ctx","getContext","imageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingQuality","requiresCanvas","minWidth","minHeight","pixelRatio","downsamplingRatio","tmp","useCanvas","HTMLCanvasElement","scaleUp","Math","max","scaleDown","min","left","top","undefined","right","bottom","contain","cover","style","floor","parseFloat","orientationCropBug","setTransform","blobSlice","Blob","webkitSlice","mozSlice","bufferSlice","ArrayBuffer","begin","end","byteLength","arr1","Uint8Array","arr2","set","buffer","metaDataParsers","jpeg","parseMetaData","that","DataView","size","maxMetaDataSize","dataView","getUint16","markerBytes","markerLength","parsers","offset","maxOffset","headLength","disableMetaDataParsers","length","disableImageHead","imageHead","replaceJPEGHead","oldHead","newHead","apply","arguments","replaceHead","head","then","fetch","Request","Response","responseHandler","response","XMLHttpRequest","responseType","req","open","headers","keys","forEach","key","setRequestHeader","withCredentials","credentials","ontimeout","send","body","originalRequiresCanvas","originalRequiresMetaData","originalTransformCoordinates","originalGetTransformedOptions","requiresCanvasOrientation","withMetaData","orientation","requiresOrientationChange","autoOrientation","requiresRot180","getImageData","exif","get","opts","exifOrientation","tmpTop","tmpRight","translate","rotate","PI","ExifMap","tagCode","defineProperty","value","ifds","map","tags","Orientation","Thumbnail","Exif","GPSInfo","Interoperability","ifd1","name","id","ExifTagTypes","getValue","dataOffset","getUint8","String","fromCharCode","ascii","littleEndian","getUint32","getInt32","getExifValue","tiffOffset","tagSize","values","str","c","tagType","shouldIncludeTag","includeTags","excludeTags","parseExifTags","dirOffset","tagOffsets","tagsNumber","dirEndOffset","tagOffset","tagNumber","tagValue","parseExifData","disableExif","thumbnailIFD","includeExifTags","excludeExifTags","disableExifOffsets","exifOffsets","exifTiffOffset","exifLittleEndian","parseExifIFD","getExifThumbnail","push","exifWriters","orientationOffset","setUint16","writeExifData","ExifMapProto","stringValues","ExposureProgram","MeteringMode","LightSource","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","ComponentsConfiguration","getText","getAll","prop","getName","ifd","subTags","Number","IptcMap","getTagValue","types","outstr","n","getStringValue","combineTagValues","newValue","Array","parseIptcTags","segmentOffset","segmentLength","segmentEnd","getInt16","iptc","iptcOffsets","isSegmentStart","getHeaderLength","ObjectName","parseIptcData","disableIptc","headerLength","disableIptcOffsets","includeIptcTags","excludeIptcTags","IptcMapProto","a","b","p","L","P","S","stringValue"],"mappings":"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","sourcesContent":["/*\n * JavaScript Load Image\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, Promise */\n\n;(function ($) {\n  'use strict'\n\n  var urlAPI = $.URL || $.webkitURL\n\n  /**\n   * Creates an object URL for a given File object.\n   *\n   * @param {Blob} blob Blob object\n   * @returns {string|boolean} Returns object URL if API exists, else false.\n   */\n  function createObjectURL(blob) {\n    return urlAPI ? urlAPI.createObjectURL(blob) : false\n  }\n\n  /**\n   * Revokes a given object URL.\n   *\n   * @param {string} url Blob object URL\n   * @returns {undefined|boolean} Returns undefined if API exists, else false.\n   */\n  function revokeObjectURL(url) {\n    return urlAPI ? urlAPI.revokeObjectURL(url) : false\n  }\n\n  /**\n   * Helper function to revoke an object URL\n   *\n   * @param {string} url Blob Object URL\n   * @param {object} [options] Options object\n   */\n  function revokeHelper(url, options) {\n    if (url && url.slice(0, 5) === 'blob:' && !(options && options.noRevoke)) {\n      revokeObjectURL(url)\n    }\n  }\n\n  /**\n   * Loads a given File object via FileReader interface.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} onload Load event callback\n   * @param {Function} [onerror] Error/Abort event callback\n   * @param {string} [method=readAsDataURL] FileReader method\n   * @returns {FileReader|boolean} Returns FileReader if API exists, else false.\n   */\n  function readFile(file, onload, onerror, method) {\n    if (!$.FileReader) return false\n    var reader = new FileReader()\n    reader.onload = function () {\n      onload.call(reader, this.result)\n    }\n    if (onerror) {\n      reader.onabort = reader.onerror = function () {\n        onerror.call(reader, this.error)\n      }\n    }\n    var readerMethod = reader[method || 'readAsDataURL']\n    if (readerMethod) {\n      readerMethod.call(reader, file)\n      return reader\n    }\n  }\n\n  /**\n   * Cross-frame instanceof check.\n   *\n   * @param {string} type Instance type\n   * @param {object} obj Object instance\n   * @returns {boolean} Returns true if the object is of the given instance.\n   */\n  function isInstanceOf(type, obj) {\n    // Cross-frame instanceof check\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']'\n  }\n\n  /**\n   * @typedef { HTMLImageElement|HTMLCanvasElement } Result\n   */\n\n  /**\n   * Loads an image for a given File object.\n   *\n   * @param {Blob|string} file Blob object or image URL\n   * @param {Function|object} [callback] Image load event callback or options\n   * @param {object} [options] Options object\n   * @returns {HTMLImageElement|FileReader|Promise<Result>} Object\n   */\n  function loadImage(file, callback, options) {\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {HTMLImageElement|FileReader} Object\n     */\n    function executor(resolve, reject) {\n      var img = document.createElement('img')\n      var url\n      /**\n       * Callback for the fetchBlob call.\n       *\n       * @param {HTMLImageElement|HTMLCanvasElement} img Error object\n       * @param {object} data Data object\n       * @returns {undefined} Undefined\n       */\n      function resolveWrapper(img, data) {\n        if (resolve === reject) {\n          // Not using Promises\n          if (resolve) resolve(img, data)\n          return\n        } else if (img instanceof Error) {\n          reject(img)\n          return\n        }\n        data = data || {} // eslint-disable-line no-param-reassign\n        data.image = img\n        resolve(data)\n      }\n      /**\n       * Callback for the fetchBlob call.\n       *\n       * @param {Blob} blob Blob object\n       * @param {Error} err Error object\n       */\n      function fetchBlobCallback(blob, err) {\n        if (err && $.console) console.log(err) // eslint-disable-line no-console\n        if (blob && isInstanceOf('Blob', blob)) {\n          file = blob // eslint-disable-line no-param-reassign\n          url = createObjectURL(file)\n        } else {\n          url = file\n          if (options && options.crossOrigin) {\n            img.crossOrigin = options.crossOrigin\n          }\n        }\n        img.src = url\n      }\n      img.onerror = function (event) {\n        revokeHelper(url, options)\n        if (reject) reject.call(img, event)\n      }\n      img.onload = function () {\n        revokeHelper(url, options)\n        var data = {\n          originalWidth: img.naturalWidth || img.width,\n          originalHeight: img.naturalHeight || img.height\n        }\n        try {\n          loadImage.transform(img, options, resolveWrapper, file, data)\n        } catch (error) {\n          if (reject) reject(error)\n        }\n      }\n      if (typeof file === 'string') {\n        if (loadImage.requiresMetaData(options)) {\n          loadImage.fetchBlob(file, fetchBlobCallback, options)\n        } else {\n          fetchBlobCallback()\n        }\n        return img\n      } else if (isInstanceOf('Blob', file) || isInstanceOf('File', file)) {\n        url = createObjectURL(file)\n        if (url) {\n          img.src = url\n          return img\n        }\n        return readFile(\n          file,\n          function (url) {\n            img.src = url\n          },\n          reject\n        )\n      }\n    }\n    if ($.Promise && typeof callback !== 'function') {\n      options = callback // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    return executor(callback, callback)\n  }\n\n  // Determines if metadata should be loaded automatically.\n  // Requires the load image meta extension to load metadata.\n  loadImage.requiresMetaData = function (options) {\n    return options && options.meta\n  }\n\n  // If the callback given to this function returns a blob, it is used as image\n  // source instead of the original url and overrides the file argument used in\n  // the onload and onerror event callbacks:\n  loadImage.fetchBlob = function (url, callback) {\n    callback()\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    callback(img, data)\n  }\n\n  loadImage.global = $\n  loadImage.readFile = readFile\n  loadImage.isInstanceOf = isInstanceOf\n  loadImage.createObjectURL = createObjectURL\n  loadImage.revokeObjectURL = revokeObjectURL\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return loadImage\n    })\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = loadImage\n  } else {\n    $.loadImage = loadImage\n  }\n})((typeof window !== 'undefined' && window) || this)\n","/*\n * JavaScript Load Image Scaling\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n\n  loadImage.createCanvas = function (width, height, offscreen) {\n    if (offscreen && loadImage.global.OffscreenCanvas) {\n      return new OffscreenCanvas(width, height)\n    }\n    var canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    return canvas\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      loadImage.scale(img, options, data),\n      options,\n      callback,\n      file,\n      data\n    )\n  }\n\n  // Transform image coordinates, allows to override e.g.\n  // the canvas orientation based on the orientation option,\n  // gets canvas, options and data passed as arguments:\n  loadImage.transformCoordinates = function () {}\n\n  // Returns transformed options, allows to override e.g.\n  // maxWidth, maxHeight and crop options based on the aspectRatio.\n  // gets img, options, data passed as arguments:\n  loadImage.getTransformedOptions = function (img, options) {\n    var aspectRatio = options.aspectRatio\n    var newOptions\n    var i\n    var width\n    var height\n    if (!aspectRatio) {\n      return options\n    }\n    newOptions = {}\n    for (i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.crop = true\n    width = img.naturalWidth || img.width\n    height = img.naturalHeight || img.height\n    if (width / height > aspectRatio) {\n      newOptions.maxWidth = height * aspectRatio\n      newOptions.maxHeight = height\n    } else {\n      newOptions.maxWidth = width\n      newOptions.maxHeight = width / aspectRatio\n    }\n    return newOptions\n  }\n\n  // Canvas render method, allows to implement a different rendering algorithm:\n  loadImage.drawImage = function (\n    img,\n    canvas,\n    sourceX,\n    sourceY,\n    sourceWidth,\n    sourceHeight,\n    destWidth,\n    destHeight,\n    options\n  ) {\n    var ctx = canvas.getContext('2d')\n    if (options.imageSmoothingEnabled === false) {\n      ctx.msImageSmoothingEnabled = false\n      ctx.imageSmoothingEnabled = false\n    } else if (options.imageSmoothingQuality) {\n      ctx.imageSmoothingQuality = options.imageSmoothingQuality\n    }\n    ctx.drawImage(\n      img,\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      0,\n      0,\n      destWidth,\n      destHeight\n    )\n    return ctx\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.requiresCanvas = function (options) {\n    return options.canvas || options.crop || !!options.aspectRatio\n  }\n\n  // Scales and/or crops the given image (img or canvas HTML element)\n  // using the given options:\n  loadImage.scale = function (img, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var useCanvas =\n      img.getContext ||\n      (loadImage.requiresCanvas(options) &&\n        !!loadImage.global.HTMLCanvasElement)\n    var width = img.naturalWidth || img.width\n    var height = img.naturalHeight || img.height\n    var destWidth = width\n    var destHeight = height\n    var maxWidth\n    var maxHeight\n    var minWidth\n    var minHeight\n    var sourceWidth\n    var sourceHeight\n    var sourceX\n    var sourceY\n    var pixelRatio\n    var downsamplingRatio\n    var tmp\n    var canvas\n    /**\n     * Scales up image dimensions\n     */\n    function scaleUp() {\n      var scale = Math.max(\n        (minWidth || destWidth) / destWidth,\n        (minHeight || destHeight) / destHeight\n      )\n      if (scale > 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    /**\n     * Scales down image dimensions\n     */\n    function scaleDown() {\n      var scale = Math.min(\n        (maxWidth || destWidth) / destWidth,\n        (maxHeight || destHeight) / destHeight\n      )\n      if (scale < 1) {\n        destWidth *= scale\n        destHeight *= scale\n      }\n    }\n    if (useCanvas) {\n      // eslint-disable-next-line no-param-reassign\n      options = loadImage.getTransformedOptions(img, options, data)\n      sourceX = options.left || 0\n      sourceY = options.top || 0\n      if (options.sourceWidth) {\n        sourceWidth = options.sourceWidth\n        if (options.right !== undefined && options.left === undefined) {\n          sourceX = width - sourceWidth - options.right\n        }\n      } else {\n        sourceWidth = width - sourceX - (options.right || 0)\n      }\n      if (options.sourceHeight) {\n        sourceHeight = options.sourceHeight\n        if (options.bottom !== undefined && options.top === undefined) {\n          sourceY = height - sourceHeight - options.bottom\n        }\n      } else {\n        sourceHeight = height - sourceY - (options.bottom || 0)\n      }\n      destWidth = sourceWidth\n      destHeight = sourceHeight\n    }\n    maxWidth = options.maxWidth\n    maxHeight = options.maxHeight\n    minWidth = options.minWidth\n    minHeight = options.minHeight\n    if (useCanvas && maxWidth && maxHeight && options.crop) {\n      destWidth = maxWidth\n      destHeight = maxHeight\n      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight\n      if (tmp < 0) {\n        sourceHeight = (maxHeight * sourceWidth) / maxWidth\n        if (options.top === undefined && options.bottom === undefined) {\n          sourceY = (height - sourceHeight) / 2\n        }\n      } else if (tmp > 0) {\n        sourceWidth = (maxWidth * sourceHeight) / maxHeight\n        if (options.left === undefined && options.right === undefined) {\n          sourceX = (width - sourceWidth) / 2\n        }\n      }\n    } else {\n      if (options.contain || options.cover) {\n        minWidth = maxWidth = maxWidth || minWidth\n        minHeight = maxHeight = maxHeight || minHeight\n      }\n      if (options.cover) {\n        scaleDown()\n        scaleUp()\n      } else {\n        scaleUp()\n        scaleDown()\n      }\n    }\n    if (useCanvas) {\n      pixelRatio = options.pixelRatio\n      if (\n        pixelRatio > 1 &&\n        // Check if the image has not yet had the device pixel ratio applied:\n        !(\n          img.style.width &&\n          Math.floor(parseFloat(img.style.width, 10)) ===\n            Math.floor(width / pixelRatio)\n        )\n      ) {\n        destWidth *= pixelRatio\n        destHeight *= pixelRatio\n      }\n      // Check if workaround for Chromium orientation crop bug is required:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1074354\n      if (\n        loadImage.orientationCropBug &&\n        !img.getContext &&\n        (sourceX || sourceY || sourceWidth !== width || sourceHeight !== height)\n      ) {\n        // Write the complete source image to an intermediate canvas first:\n        tmp = img\n        // eslint-disable-next-line no-param-reassign\n        img = loadImage.createCanvas(width, height, true)\n        loadImage.drawImage(\n          tmp,\n          img,\n          0,\n          0,\n          width,\n          height,\n          width,\n          height,\n          options\n        )\n      }\n      downsamplingRatio = options.downsamplingRatio\n      if (\n        downsamplingRatio > 0 &&\n        downsamplingRatio < 1 &&\n        destWidth < sourceWidth &&\n        destHeight < sourceHeight\n      ) {\n        while (sourceWidth * downsamplingRatio > destWidth) {\n          canvas = loadImage.createCanvas(\n            sourceWidth * downsamplingRatio,\n            sourceHeight * downsamplingRatio,\n            true\n          )\n          loadImage.drawImage(\n            img,\n            canvas,\n            sourceX,\n            sourceY,\n            sourceWidth,\n            sourceHeight,\n            canvas.width,\n            canvas.height,\n            options\n          )\n          sourceX = 0\n          sourceY = 0\n          sourceWidth = canvas.width\n          sourceHeight = canvas.height\n          // eslint-disable-next-line no-param-reassign\n          img = canvas\n        }\n      }\n      canvas = loadImage.createCanvas(destWidth, destHeight)\n      loadImage.transformCoordinates(canvas, options, data)\n      if (pixelRatio > 1) {\n        canvas.style.width = canvas.width / pixelRatio + 'px'\n      }\n      loadImage\n        .drawImage(\n          img,\n          canvas,\n          sourceX,\n          sourceY,\n          sourceWidth,\n          sourceHeight,\n          destWidth,\n          destHeight,\n          options\n        )\n        .setTransform(1, 0, 0, 1, 0, 0) // reset to the identity matrix\n      return canvas\n    }\n    img.width = destWidth\n    img.height = destHeight\n    return img\n  }\n})\n","/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image metadata handling implementation\n * based on the help and contribution of\n * Achim St√∂hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise, DataView, Uint8Array, ArrayBuffer */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n  var originalTransform = loadImage.transform\n\n  var blobSlice =\n    global.Blob &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  var bufferSlice =\n    (global.ArrayBuffer && ArrayBuffer.prototype.slice) ||\n    function (begin, end) {\n      // Polyfill for IE10, which does not support ArrayBuffer.slice\n      // eslint-disable-next-line no-param-reassign\n      end = end || this.byteLength - begin\n      var arr1 = new Uint8Array(this, begin, end)\n      var arr2 = new Uint8Array(end)\n      arr2.set(arr1)\n      return arr2.buffer\n    }\n\n  var metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  /**\n   * Parses image metadata and calls the callback with an object argument\n   * with the following property:\n   * - imageHead: The complete image head as ArrayBuffer\n   * The options argument accepts an object and supports the following\n   * properties:\n   * - maxMetaDataSize: Defines the maximum number of bytes to parse.\n   * - disableImageHead: Disables creating the imageHead property.\n   *\n   * @param {Blob} file Blob object\n   * @param {Function} [callback] Callback function\n   * @param {object} [options] Parsing options\n   * @param {object} [data] Result data object\n   * @returns {Promise<object>|undefined} Returns Promise if no callback given.\n   */\n  function parseMetaData(file, callback, options, data) {\n    var that = this\n    /**\n     * Promise executor\n     *\n     * @param {Function} resolve Resolution function\n     * @param {Function} reject Rejection function\n     * @returns {undefined} Undefined\n     */\n    function executor(resolve, reject) {\n      if (\n        !(\n          global.DataView &&\n          blobSlice &&\n          file &&\n          file.size >= 12 &&\n          file.type === 'image/jpeg'\n        )\n      ) {\n        // Nothing to parse\n        return resolve(data)\n      }\n      // 256 KiB should contain all EXIF/ICC/IPTC segments:\n      var maxMetaDataSize = options.maxMetaDataSize || 262144\n      if (\n        !loadImage.readFile(\n          blobSlice.call(file, 0, maxMetaDataSize),\n          function (buffer) {\n            // Note on endianness:\n            // Since the marker and length bytes in JPEG files are always\n            // stored in big endian order, we can leave the endian parameter\n            // of the DataView methods undefined, defaulting to big endian.\n            var dataView = new DataView(buffer)\n            // Check for the JPEG marker (0xffd8):\n            if (dataView.getUint16(0) !== 0xffd8) {\n              return reject(\n                new Error('Invalid JPEG file: Missing JPEG marker.')\n              )\n            }\n            var offset = 2\n            var maxOffset = dataView.byteLength - 4\n            var headLength = offset\n            var markerBytes\n            var markerLength\n            var parsers\n            var i\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific metadata like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid JPEG metadata: Invalid segment size.')\n                  break\n                }\n                parsers = metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the metadata\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              data.imageHead = bufferSlice.call(buffer, 0, headLength)\n            }\n            resolve(data)\n          },\n          reject,\n          'readAsArrayBuffer'\n        )\n      ) {\n        // No support for the FileReader interface, nothing to parse\n        resolve(data)\n      }\n    }\n    options = options || {} // eslint-disable-line no-param-reassign\n    if (global.Promise && typeof callback !== 'function') {\n      options = callback || {} // eslint-disable-line no-param-reassign\n      data = options // eslint-disable-line no-param-reassign\n      return new Promise(executor)\n    }\n    data = data || {} // eslint-disable-line no-param-reassign\n    return executor(callback, callback)\n  }\n\n  /**\n   * Replaces the head of a JPEG Blob\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} oldHead Old JPEG head\n   * @param {ArrayBuffer} newHead New JPEG head\n   * @returns {Blob} Combined Blob\n   */\n  function replaceJPEGHead(blob, oldHead, newHead) {\n    if (!blob || !oldHead || !newHead) return null\n    return new Blob([newHead, blobSlice.call(blob, oldHead.byteLength)], {\n      type: 'image/jpeg'\n    })\n  }\n\n  /**\n   * Replaces the image head of a JPEG blob with the given one.\n   * Returns a Promise or calls the callback with the new Blob.\n   *\n   * @param {Blob} blob Blob object\n   * @param {ArrayBuffer} head New JPEG head\n   * @param {Function} [callback] Callback function\n   * @returns {Promise<Blob|null>|undefined} Combined Blob\n   */\n  function replaceHead(blob, head, callback) {\n    var options = { maxMetaDataSize: 1024, disableMetaDataParsers: true }\n    if (!callback && global.Promise) {\n      return parseMetaData(blob, options).then(function (data) {\n        return replaceJPEGHead(blob, data.imageHead, head)\n      })\n    }\n    parseMetaData(\n      blob,\n      function (data) {\n        callback(replaceJPEGHead(blob, data.imageHead, head))\n      },\n      options\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.requiresMetaData(options)) {\n      data = data || {} // eslint-disable-line no-param-reassign\n      parseMetaData(\n        file,\n        function (result) {\n          if (result !== data) {\n            // eslint-disable-next-line no-console\n            if (global.console) console.log(result)\n            result = data // eslint-disable-line no-param-reassign\n          }\n          originalTransform.call(\n            loadImage,\n            img,\n            options,\n            callback,\n            file,\n            result\n          )\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n\n  loadImage.blobSlice = blobSlice\n  loadImage.bufferSlice = bufferSlice\n  loadImage.replaceHead = replaceHead\n  loadImage.parseMetaData = parseMetaData\n  loadImage.metaDataParsers = metaDataParsers\n})\n","/*\n * JavaScript Load Image Fetch\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2017, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, Promise */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var global = loadImage.global\n\n  if (\n    global.fetch &&\n    global.Request &&\n    global.Response &&\n    global.Response.prototype.blob\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      /**\n       * Fetch response handler.\n       *\n       * @param {Response} response Fetch response\n       * @returns {Blob} Fetched Blob.\n       */\n      function responseHandler(response) {\n        return response.blob()\n      }\n      if (global.Promise && typeof callback !== 'function') {\n        return fetch(new Request(url, callback)).then(responseHandler)\n      }\n      fetch(new Request(url, options))\n        .then(responseHandler)\n        .then(callback)\n        [\n          // Avoid parsing error in IE<9, where catch is a reserved word.\n          // eslint-disable-next-line dot-notation\n          'catch'\n        ](function (err) {\n          callback(null, err)\n        })\n    }\n  } else if (\n    global.XMLHttpRequest &&\n    // https://xhr.spec.whatwg.org/#the-responsetype-attribute\n    new XMLHttpRequest().responseType === ''\n  ) {\n    loadImage.fetchBlob = function (url, callback, options) {\n      /**\n       * Promise executor\n       *\n       * @param {Function} resolve Resolution function\n       * @param {Function} reject Rejection function\n       */\n      function executor(resolve, reject) {\n        options = options || {} // eslint-disable-line no-param-reassign\n        var req = new XMLHttpRequest()\n        req.open(options.method || 'GET', url)\n        if (options.headers) {\n          Object.keys(options.headers).forEach(function (key) {\n            req.setRequestHeader(key, options.headers[key])\n          })\n        }\n        req.withCredentials = options.credentials === 'include'\n        req.responseType = 'blob'\n        req.onload = function () {\n          resolve(req.response)\n        }\n        req.onerror =\n          req.onabort =\n          req.ontimeout =\n            function (err) {\n              if (resolve === reject) {\n                // Not using Promises\n                reject(null, err)\n              } else {\n                reject(err)\n              }\n            }\n        req.send(options.body)\n      }\n      if (global.Promise && typeof callback !== 'function') {\n        options = callback // eslint-disable-line no-param-reassign\n        return new Promise(executor)\n      }\n      return executor(callback, callback)\n    }\n  }\n})\n","/*\n * JavaScript Load Image Orientation\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/*\nExif orientation values to correctly display the letter F:\n\n    1             2\n  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n  ‚ñà‚ñà                ‚ñà‚ñà\n  ‚ñà‚ñà‚ñà‚ñà            ‚ñà‚ñà‚ñà‚ñà\n  ‚ñà‚ñà                ‚ñà‚ñà\n  ‚ñà‚ñà                ‚ñà‚ñà\n\n    3             4\n      ‚ñà‚ñà        ‚ñà‚ñà\n      ‚ñà‚ñà        ‚ñà‚ñà\n    ‚ñà‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà‚ñà\n      ‚ñà‚ñà        ‚ñà‚ñà\n  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n\n    5             6\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà\n‚ñà‚ñà  ‚ñà‚ñà        ‚ñà‚ñà  ‚ñà‚ñà\n‚ñà‚ñà            ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n\n    7             8\n        ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\n    ‚ñà‚ñà  ‚ñà‚ñà        ‚ñà‚ñà  ‚ñà‚ñà\n‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà            ‚ñà‚ñà\n\n*/\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-scale', './load-image-meta'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(\n      require('./load-image'),\n      require('./load-image-scale'),\n      require('./load-image-meta')\n    )\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var originalTransform = loadImage.transform\n  var originalRequiresCanvas = loadImage.requiresCanvas\n  var originalRequiresMetaData = loadImage.requiresMetaData\n  var originalTransformCoordinates = loadImage.transformCoordinates\n  var originalGetTransformedOptions = loadImage.getTransformedOptions\n\n  ;(function ($) {\n    // Guard for non-browser environments (e.g. server-side rendering):\n    if (!$.global.document) return\n    // black+white 3x2 JPEG, with the following meta information set:\n    // - EXIF Orientation: 6 (Rotated 90¬∞ CCW)\n    // Image data layout (B=black, F=white):\n    // BFF\n    // BBB\n    var testImageURL =\n      'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\n      'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\n      'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\n      'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAIAAwMBEQACEQEDEQH/x' +\n      'ABRAAEAAAAAAAAAAAAAAAAAAAAKEAEBAQADAQEAAAAAAAAAAAAGBQQDCAkCBwEBAAAAAAA' +\n      'AAAAAAAAAAAAAABEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8AG8T9NfSMEVMhQ' +\n      'voP3fFiRZ+MTHDifa/95OFSZU5OzRzxkyejv8ciEfhSceSXGjS8eSdLnZc2HDm4M3BxcXw' +\n      'H/9k='\n    var img = document.createElement('img')\n    img.onload = function () {\n      // Check if the browser supports automatic image orientation:\n      $.orientation = img.width === 2 && img.height === 3\n      if ($.orientation) {\n        var canvas = $.createCanvas(1, 1, true)\n        var ctx = canvas.getContext('2d')\n        ctx.drawImage(img, 1, 1, 1, 1, 0, 0, 1, 1)\n        // Check if the source image coordinates (sX, sY, sWidth, sHeight) are\n        // correctly applied to the auto-orientated image, which should result\n        // in a white opaque pixel (e.g. in Safari).\n        // Browsers that show a transparent pixel (e.g. Chromium) fail to crop\n        // auto-oriented images correctly and require a workaround, e.g.\n        // drawing the complete source image to an intermediate canvas first.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1074354\n        $.orientationCropBug =\n          ctx.getImageData(0, 0, 1, 1).data.toString() !== '255,255,255,255'\n      }\n    }\n    img.src = testImageURL\n  })(loadImage)\n\n  /**\n   * Determines if the orientation requires a canvas element.\n   *\n   * @param {object} [options] Options object\n   * @param {boolean} [withMetaData] Is metadata required for orientation\n   * @returns {boolean} Returns true if orientation requires canvas/meta\n   */\n  function requiresCanvasOrientation(options, withMetaData) {\n    var orientation = options && options.orientation\n    return (\n      // Exif orientation for browsers without automatic image orientation:\n      (orientation === true && !loadImage.orientation) ||\n      // Orientation reset for browsers with automatic image orientation:\n      (orientation === 1 && loadImage.orientation) ||\n      // Orientation to defined value, requires meta for orientation reset only:\n      ((!withMetaData || loadImage.orientation) &&\n        orientation > 1 &&\n        orientation < 9)\n    )\n  }\n\n  /**\n   * Determines if the image requires an orientation change.\n   *\n   * @param {number} [orientation] Defined orientation value\n   * @param {number} [autoOrientation] Auto-orientation based on Exif data\n   * @returns {boolean} Returns true if an orientation change is required\n   */\n  function requiresOrientationChange(orientation, autoOrientation) {\n    return (\n      orientation !== autoOrientation &&\n      ((orientation === 1 && autoOrientation > 1 && autoOrientation < 9) ||\n        (orientation > 1 && orientation < 9))\n    )\n  }\n\n  /**\n   * Determines orientation combinations that require a rotation by 180¬∞.\n   *\n   * The following is a list of combinations that return true:\n   *\n   * 2 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)\n   * 4 (flip) => 5 (rot90,flip), 7 (rot90,flip), 6 (rot90), 8 (rot90)\n   *\n   * 5 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)\n   * 7 (rot90,flip) => 2 (flip), 4 (flip), 6 (rot90), 8 (rot90)\n   *\n   * 6 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)\n   * 8 (rot90) => 2 (flip), 4 (flip), 5 (rot90,flip), 7 (rot90,flip)\n   *\n   * @param {number} [orientation] Defined orientation value\n   * @param {number} [autoOrientation] Auto-orientation based on Exif data\n   * @returns {boolean} Returns true if rotation by 180¬∞ is required\n   */\n  function requiresRot180(orientation, autoOrientation) {\n    if (autoOrientation > 1 && autoOrientation < 9) {\n      switch (orientation) {\n        case 2:\n        case 4:\n          return autoOrientation > 4\n        case 5:\n        case 7:\n          return autoOrientation % 2 === 0\n        case 6:\n        case 8:\n          return (\n            autoOrientation === 2 ||\n            autoOrientation === 4 ||\n            autoOrientation === 5 ||\n            autoOrientation === 7\n          )\n      }\n    }\n    return false\n  }\n\n  // Determines if the target image should be a canvas element:\n  loadImage.requiresCanvas = function (options) {\n    return (\n      requiresCanvasOrientation(options) ||\n      originalRequiresCanvas.call(loadImage, options)\n    )\n  }\n\n  // Determines if metadata should be loaded automatically:\n  loadImage.requiresMetaData = function (options) {\n    return (\n      requiresCanvasOrientation(options, true) ||\n      originalRequiresMetaData.call(loadImage, options)\n    )\n  }\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    originalTransform.call(\n      loadImage,\n      img,\n      options,\n      function (img, data) {\n        if (data) {\n          var autoOrientation =\n            loadImage.orientation && data.exif && data.exif.get('Orientation')\n          if (autoOrientation > 4 && autoOrientation < 9) {\n            // Automatic image orientation switched image dimensions\n            var originalWidth = data.originalWidth\n            var originalHeight = data.originalHeight\n            data.originalWidth = originalHeight\n            data.originalHeight = originalWidth\n          }\n        }\n        callback(img, data)\n      },\n      file,\n      data\n    )\n  }\n\n  // Transforms coordinate and dimension options\n  // based on the given orientation option:\n  loadImage.getTransformedOptions = function (img, opts, data) {\n    var options = originalGetTransformedOptions.call(loadImage, img, opts)\n    var exifOrientation = data.exif && data.exif.get('Orientation')\n    var orientation = options.orientation\n    var autoOrientation = loadImage.orientation && exifOrientation\n    if (orientation === true) orientation = exifOrientation\n    if (!requiresOrientationChange(orientation, autoOrientation)) {\n      return options\n    }\n    var top = options.top\n    var right = options.right\n    var bottom = options.bottom\n    var left = options.left\n    var newOptions = {}\n    for (var i in options) {\n      if (Object.prototype.hasOwnProperty.call(options, i)) {\n        newOptions[i] = options[i]\n      }\n    }\n    newOptions.orientation = orientation\n    if (\n      (orientation > 4 && !(autoOrientation > 4)) ||\n      (orientation < 5 && autoOrientation > 4)\n    ) {\n      // Image dimensions and target dimensions are switched\n      newOptions.maxWidth = options.maxHeight\n      newOptions.maxHeight = options.maxWidth\n      newOptions.minWidth = options.minHeight\n      newOptions.minHeight = options.minWidth\n      newOptions.sourceWidth = options.sourceHeight\n      newOptions.sourceHeight = options.sourceWidth\n    }\n    if (autoOrientation > 1) {\n      // Browsers which correctly apply source image coordinates to\n      // auto-oriented images\n      switch (autoOrientation) {\n        case 2:\n          // Horizontal flip\n          right = options.left\n          left = options.right\n          break\n        case 3:\n          // 180¬∞ Rotate CCW\n          top = options.bottom\n          right = options.left\n          bottom = options.top\n          left = options.right\n          break\n        case 4:\n          // Vertical flip\n          top = options.bottom\n          bottom = options.top\n          break\n        case 5:\n          // Horizontal flip + 90¬∞ Rotate CCW\n          top = options.left\n          right = options.bottom\n          bottom = options.right\n          left = options.top\n          break\n        case 6:\n          // 90¬∞ Rotate CCW\n          top = options.left\n          right = options.top\n          bottom = options.right\n          left = options.bottom\n          break\n        case 7:\n          // Vertical flip + 90¬∞ Rotate CCW\n          top = options.right\n          right = options.top\n          bottom = options.left\n          left = options.bottom\n          break\n        case 8:\n          // 90¬∞ Rotate CW\n          top = options.right\n          right = options.bottom\n          bottom = options.left\n          left = options.top\n          break\n      }\n      // Some orientation combinations require additional rotation by 180¬∞:\n      if (requiresRot180(orientation, autoOrientation)) {\n        var tmpTop = top\n        var tmpRight = right\n        top = bottom\n        right = left\n        bottom = tmpTop\n        left = tmpRight\n      }\n    }\n    newOptions.top = top\n    newOptions.right = right\n    newOptions.bottom = bottom\n    newOptions.left = left\n    // Account for defined browser orientation:\n    switch (orientation) {\n      case 2:\n        // Horizontal flip\n        newOptions.right = left\n        newOptions.left = right\n        break\n      case 3:\n        // 180¬∞ Rotate CCW\n        newOptions.top = bottom\n        newOptions.right = left\n        newOptions.bottom = top\n        newOptions.left = right\n        break\n      case 4:\n        // Vertical flip\n        newOptions.top = bottom\n        newOptions.bottom = top\n        break\n      case 5:\n        // Vertical flip + 90¬∞ Rotate CW\n        newOptions.top = left\n        newOptions.right = bottom\n        newOptions.bottom = right\n        newOptions.left = top\n        break\n      case 6:\n        // 90¬∞ Rotate CW\n        newOptions.top = right\n        newOptions.right = bottom\n        newOptions.bottom = left\n        newOptions.left = top\n        break\n      case 7:\n        // Horizontal flip + 90¬∞ Rotate CW\n        newOptions.top = right\n        newOptions.right = top\n        newOptions.bottom = left\n        newOptions.left = bottom\n        break\n      case 8:\n        // 90¬∞ Rotate CCW\n        newOptions.top = left\n        newOptions.right = top\n        newOptions.bottom = right\n        newOptions.left = bottom\n        break\n    }\n    return newOptions\n  }\n\n  // Transform image orientation based on the given EXIF orientation option:\n  loadImage.transformCoordinates = function (canvas, options, data) {\n    originalTransformCoordinates.call(loadImage, canvas, options, data)\n    var orientation = options.orientation\n    var autoOrientation =\n      loadImage.orientation && data.exif && data.exif.get('Orientation')\n    if (!requiresOrientationChange(orientation, autoOrientation)) {\n      return\n    }\n    var ctx = canvas.getContext('2d')\n    var width = canvas.width\n    var height = canvas.height\n    var sourceWidth = width\n    var sourceHeight = height\n    if (\n      (orientation > 4 && !(autoOrientation > 4)) ||\n      (orientation < 5 && autoOrientation > 4)\n    ) {\n      // Image dimensions and target dimensions are switched\n      canvas.width = height\n      canvas.height = width\n    }\n    if (orientation > 4) {\n      // Destination and source dimensions are switched\n      sourceWidth = height\n      sourceHeight = width\n    }\n    // Reset automatic browser orientation:\n    switch (autoOrientation) {\n      case 2:\n        // Horizontal flip\n        ctx.translate(sourceWidth, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180¬∞ Rotate CCW\n        ctx.translate(sourceWidth, sourceHeight)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // Vertical flip\n        ctx.translate(0, sourceHeight)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // Horizontal flip + 90¬∞ Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.scale(-1, 1)\n        break\n      case 6:\n        // 90¬∞ Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-sourceWidth, 0)\n        break\n      case 7:\n        // Vertical flip + 90¬∞ Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-sourceWidth, sourceHeight)\n        ctx.scale(1, -1)\n        break\n      case 8:\n        // 90¬∞ Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -sourceHeight)\n        break\n    }\n    // Some orientation combinations require additional rotation by 180¬∞:\n    if (requiresRot180(orientation, autoOrientation)) {\n      ctx.translate(sourceWidth, sourceHeight)\n      ctx.rotate(Math.PI)\n    }\n    switch (orientation) {\n      case 2:\n        // Horizontal flip\n        ctx.translate(width, 0)\n        ctx.scale(-1, 1)\n        break\n      case 3:\n        // 180¬∞ Rotate CCW\n        ctx.translate(width, height)\n        ctx.rotate(Math.PI)\n        break\n      case 4:\n        // Vertical flip\n        ctx.translate(0, height)\n        ctx.scale(1, -1)\n        break\n      case 5:\n        // Vertical flip + 90¬∞ Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.scale(1, -1)\n        break\n      case 6:\n        // 90¬∞ Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(0, -height)\n        break\n      case 7:\n        // Horizontal flip + 90¬∞ Rotate CW\n        ctx.rotate(0.5 * Math.PI)\n        ctx.translate(width, -height)\n        ctx.scale(-1, 1)\n        break\n      case 8:\n        // 90¬∞ Rotate CCW\n        ctx.rotate(-0.5 * Math.PI)\n        ctx.translate(-width, 0)\n        break\n    }\n  }\n})\n","/*\n * JavaScript Load Image Exif Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n/* eslint-disable no-console */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  /**\n   * Exif tag map\n   *\n   * @name ExifMap\n   * @class\n   * @param {number|string} tagCode IFD tag code\n   */\n  function ExifMap(tagCode) {\n    if (tagCode) {\n      Object.defineProperty(this, 'map', {\n        value: this.ifds[tagCode].map\n      })\n      Object.defineProperty(this, 'tags', {\n        value: (this.tags && this.tags[tagCode]) || {}\n      })\n    }\n  }\n\n  ExifMap.prototype.map = {\n    Orientation: 0x0112,\n    Thumbnail: 'ifd1',\n    Blob: 0x0201, // Alias for JPEGInterchangeFormat\n    Exif: 0x8769,\n    GPSInfo: 0x8825,\n    Interoperability: 0xa005\n  }\n\n  ExifMap.prototype.ifds = {\n    ifd1: { name: 'Thumbnail', map: ExifMap.prototype.map },\n    0x8769: { name: 'Exif', map: {} },\n    0x8825: { name: 'GPSInfo', map: {} },\n    0xa005: { name: 'Interoperability', map: {} }\n  }\n\n  /**\n   * Retrieves exif tag value\n   *\n   * @param {number|string} id Exif tag code or name\n   * @returns {object} Exif tag value\n   */\n  ExifMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  /**\n   * Returns the Exif Thumbnail data as Blob.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Thumbnail data offset\n   * @param {number} length Thumbnail data length\n   * @returns {undefined|Blob} Returns the Thumbnail Blob or undefined\n   */\n  function getExifThumbnail(dataView, offset, length) {\n    if (!length) return\n    if (offset + length > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid thumbnail data.')\n      return\n    }\n    return new Blob(\n      [loadImage.bufferSlice.call(dataView.buffer, offset, offset + length)],\n      {\n        type: 'image/jpeg'\n      }\n    )\n  }\n\n  var ExifTagTypes = {\n    // byte, 8-bit unsigned int:\n    1: {\n      getValue: function (dataView, dataOffset) {\n        return dataView.getUint8(dataOffset)\n      },\n      size: 1\n    },\n    // ascii, 8-bit byte:\n    2: {\n      getValue: function (dataView, dataOffset) {\n        return String.fromCharCode(dataView.getUint8(dataOffset))\n      },\n      size: 1,\n      ascii: true\n    },\n    // short, 16 bit int:\n    3: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint16(dataOffset, littleEndian)\n      },\n      size: 2\n    },\n    // long, 32 bit int:\n    4: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getUint32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // rational = two long values, first is numerator, second is denominator:\n    5: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getUint32(dataOffset, littleEndian) /\n          dataView.getUint32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    },\n    // slong, 32 bit signed int:\n    9: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return dataView.getInt32(dataOffset, littleEndian)\n      },\n      size: 4\n    },\n    // srational, two slongs, first is numerator, second is denominator:\n    10: {\n      getValue: function (dataView, dataOffset, littleEndian) {\n        return (\n          dataView.getInt32(dataOffset, littleEndian) /\n          dataView.getInt32(dataOffset + 4, littleEndian)\n        )\n      },\n      size: 8\n    }\n  }\n  // undefined, 8-bit byte, value depending on field:\n  ExifTagTypes[7] = ExifTagTypes[1]\n\n  /**\n   * Returns Exif tag value.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {number} offset Tag offset\n   * @param {number} type Tag type\n   * @param {number} length Tag length\n   * @param {boolean} littleEndian Little endian encoding\n   * @returns {object} Tag value\n   */\n  function getExifValue(\n    dataView,\n    tiffOffset,\n    offset,\n    type,\n    length,\n    littleEndian\n  ) {\n    var tagType = ExifTagTypes[type]\n    var tagSize\n    var dataOffset\n    var values\n    var i\n    var str\n    var c\n    if (!tagType) {\n      console.log('Invalid Exif data: Invalid tag type.')\n      return\n    }\n    tagSize = tagType.size * length\n    // Determine if the value is contained in the dataOffset bytes,\n    // or if the value at the dataOffset is a pointer to the actual data:\n    dataOffset =\n      tagSize > 4\n        ? tiffOffset + dataView.getUint32(offset + 8, littleEndian)\n        : offset + 8\n    if (dataOffset + tagSize > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid data offset.')\n      return\n    }\n    if (length === 1) {\n      return tagType.getValue(dataView, dataOffset, littleEndian)\n    }\n    values = []\n    for (i = 0; i < length; i += 1) {\n      values[i] = tagType.getValue(\n        dataView,\n        dataOffset + i * tagType.size,\n        littleEndian\n      )\n    }\n    if (tagType.ascii) {\n      str = ''\n      // Concatenate the chars:\n      for (i = 0; i < values.length; i += 1) {\n        c = values[i]\n        // Ignore the terminating NULL byte(s):\n        if (c === '\\u0000') {\n          break\n        }\n        str += c\n      }\n      return str\n    }\n    return values\n  }\n\n  /**\n   * Determines if the given tag should be included.\n   *\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   * @param {number|string} tagCode Tag code to check\n   * @returns {boolean} True if the tag should be included\n   */\n  function shouldIncludeTag(includeTags, excludeTags, tagCode) {\n    return (\n      (!includeTags || includeTags[tagCode]) &&\n      (!excludeTags || excludeTags[tagCode] !== true)\n    )\n  }\n\n  /**\n   * Parses Exif tags.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {number} dirOffset Directory offset\n   * @param {boolean} littleEndian Little endian encoding\n   * @param {ExifMap} tags Map to store parsed exif tags\n   * @param {ExifMap} tagOffsets Map to store parsed exif tag offsets\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   * @returns {number} Next directory offset\n   */\n  function parseExifTags(\n    dataView,\n    tiffOffset,\n    dirOffset,\n    littleEndian,\n    tags,\n    tagOffsets,\n    includeTags,\n    excludeTags\n  ) {\n    var tagsNumber, dirEndOffset, i, tagOffset, tagNumber, tagValue\n    if (dirOffset + 6 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory offset.')\n      return\n    }\n    tagsNumber = dataView.getUint16(dirOffset, littleEndian)\n    dirEndOffset = dirOffset + 2 + 12 * tagsNumber\n    if (dirEndOffset + 4 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid directory size.')\n      return\n    }\n    for (i = 0; i < tagsNumber; i += 1) {\n      tagOffset = dirOffset + 2 + 12 * i\n      tagNumber = dataView.getUint16(tagOffset, littleEndian)\n      if (!shouldIncludeTag(includeTags, excludeTags, tagNumber)) continue\n      tagValue = getExifValue(\n        dataView,\n        tiffOffset,\n        tagOffset,\n        dataView.getUint16(tagOffset + 2, littleEndian), // tag type\n        dataView.getUint32(tagOffset + 4, littleEndian), // tag length\n        littleEndian\n      )\n      tags[tagNumber] = tagValue\n      if (tagOffsets) {\n        tagOffsets[tagNumber] = tagOffset\n      }\n    }\n    // Return the offset to the next directory:\n    return dataView.getUint32(dirEndOffset, littleEndian)\n  }\n\n  /**\n   * Parses tags in a given IFD (Image File Directory).\n   *\n   * @param {object} data Data object to store exif tags and offsets\n   * @param {number|string} tagCode IFD tag code\n   * @param {DataView} dataView Data view interface\n   * @param {number} tiffOffset TIFF offset\n   * @param {boolean} littleEndian Little endian encoding\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   */\n  function parseExifIFD(\n    data,\n    tagCode,\n    dataView,\n    tiffOffset,\n    littleEndian,\n    includeTags,\n    excludeTags\n  ) {\n    var dirOffset = data.exif[tagCode]\n    if (dirOffset) {\n      data.exif[tagCode] = new ExifMap(tagCode)\n      if (data.exifOffsets) {\n        data.exifOffsets[tagCode] = new ExifMap(tagCode)\n      }\n      parseExifTags(\n        dataView,\n        tiffOffset,\n        tiffOffset + dirOffset,\n        littleEndian,\n        data.exif[tagCode],\n        data.exifOffsets && data.exifOffsets[tagCode],\n        includeTags && includeTags[tagCode],\n        excludeTags && excludeTags[tagCode]\n      )\n    }\n  }\n\n  loadImage.parseExifData = function (dataView, offset, length, data, options) {\n    if (options.disableExif) {\n      return\n    }\n    var includeTags = options.includeExifTags\n    var excludeTags = options.excludeExifTags || {\n      0x8769: {\n        // ExifIFDPointer\n        0x927c: true // MakerNote\n      }\n    }\n    var tiffOffset = offset + 10\n    var littleEndian\n    var dirOffset\n    var thumbnailIFD\n    // Check for the ASCII code for \"Exif\" (0x45786966):\n    if (dataView.getUint32(offset + 4) !== 0x45786966) {\n      // No Exif data, might be XMP data instead\n      return\n    }\n    if (tiffOffset + 8 > dataView.byteLength) {\n      console.log('Invalid Exif data: Invalid segment size.')\n      return\n    }\n    // Check for the two null bytes:\n    if (dataView.getUint16(offset + 8) !== 0x0000) {\n      console.log('Invalid Exif data: Missing byte alignment offset.')\n      return\n    }\n    // Check the byte alignment:\n    switch (dataView.getUint16(tiffOffset)) {\n      case 0x4949:\n        littleEndian = true\n        break\n      case 0x4d4d:\n        littleEndian = false\n        break\n      default:\n        console.log('Invalid Exif data: Invalid byte alignment marker.')\n        return\n    }\n    // Check for the TIFF tag marker (0x002A):\n    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002a) {\n      console.log('Invalid Exif data: Missing TIFF marker.')\n      return\n    }\n    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:\n    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian)\n    // Create the exif object to store the tags:\n    data.exif = new ExifMap()\n    if (!options.disableExifOffsets) {\n      data.exifOffsets = new ExifMap()\n      data.exifTiffOffset = tiffOffset\n      data.exifLittleEndian = littleEndian\n    }\n    // Parse the tags of the main image directory (IFD0) and retrieve the\n    // offset to the next directory (IFD1), usually the thumbnail directory:\n    dirOffset = parseExifTags(\n      dataView,\n      tiffOffset,\n      tiffOffset + dirOffset,\n      littleEndian,\n      data.exif,\n      data.exifOffsets,\n      includeTags,\n      excludeTags\n    )\n    if (dirOffset && shouldIncludeTag(includeTags, excludeTags, 'ifd1')) {\n      data.exif.ifd1 = dirOffset\n      if (data.exifOffsets) {\n        data.exifOffsets.ifd1 = tiffOffset + dirOffset\n      }\n    }\n    Object.keys(data.exif.ifds).forEach(function (tagCode) {\n      parseExifIFD(\n        data,\n        tagCode,\n        dataView,\n        tiffOffset,\n        littleEndian,\n        includeTags,\n        excludeTags\n      )\n    })\n    thumbnailIFD = data.exif.ifd1\n    // Check for JPEG Thumbnail offset and data length:\n    if (thumbnailIFD && thumbnailIFD[0x0201]) {\n      thumbnailIFD[0x0201] = getExifThumbnail(\n        dataView,\n        tiffOffset + thumbnailIFD[0x0201],\n        thumbnailIFD[0x0202] // Thumbnail data length\n      )\n    }\n  }\n\n  // Registers the Exif parser for the APP1 JPEG metadata segment:\n  loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData)\n\n  loadImage.exifWriters = {\n    // Orientation writer:\n    0x0112: function (buffer, data, value) {\n      var orientationOffset = data.exifOffsets[0x0112]\n      if (!orientationOffset) return buffer\n      var view = new DataView(buffer, orientationOffset + 8, 2)\n      view.setUint16(0, value, data.exifLittleEndian)\n      return buffer\n    }\n  }\n\n  loadImage.writeExifData = function (buffer, data, id, value) {\n    return loadImage.exifWriters[data.exif.map[id]](buffer, data, value)\n  }\n\n  loadImage.ExifMap = ExifMap\n\n  // Adds the following properties to the parseMetaData callback data:\n  // - exif: The parsed Exif tags\n  // - exifOffsets: The parsed Exif tag offsets\n  // - exifTiffOffset: TIFF header offset (used for offset pointers)\n  // - exifLittleEndian: little endian order if true, big endian if false\n\n  // Adds the following options to the parseMetaData method:\n  // - disableExif: Disables Exif parsing when true.\n  // - disableExifOffsets: Disables storing Exif tag offsets when true.\n  // - includeExifTags: A map of Exif tags to include for parsing.\n  // - excludeExifTags: A map of Exif tags to exclude from parsing.\n})\n","/*\n * JavaScript Load Image Exif Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Exif tags mapping based on\n * https://github.com/jseidelin/exif-js\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-exif'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-exif'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var ExifMapProto = loadImage.ExifMap.prototype\n\n  ExifMapProto.tags = {\n    // =================\n    // TIFF tags (IFD0):\n    // =================\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011c: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011a: 'XResolution',\n    0x011b: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012d: 'TransferFunction',\n    0x013e: 'WhitePoint',\n    0x013f: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010e: 'ImageDescription',\n    0x010f: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013b: 'Artist',\n    0x8298: 'Copyright',\n    0x8769: {\n      // ExifIFDPointer\n      0x9000: 'ExifVersion', // EXIF version\n      0xa000: 'FlashpixVersion', // Flashpix format version\n      0xa001: 'ColorSpace', // Color space information tag\n      0xa002: 'PixelXDimension', // Valid width of meaningful image\n      0xa003: 'PixelYDimension', // Valid height of meaningful image\n      0xa500: 'Gamma',\n      0x9101: 'ComponentsConfiguration', // Information about channels\n      0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel\n      0x927c: 'MakerNote', // Any desired information written by the manufacturer\n      0x9286: 'UserComment', // Comments by user\n      0xa004: 'RelatedSoundFile', // Name of related sound file\n      0x9003: 'DateTimeOriginal', // Date and time when the original image was generated\n      0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally\n      0x9010: 'OffsetTime', // Time zone when the image file was last changed\n      0x9011: 'OffsetTimeOriginal', // Time zone when the image was stored digitally\n      0x9012: 'OffsetTimeDigitized', // Time zone when the image was stored digitally\n      0x9290: 'SubSecTime', // Fractions of seconds for DateTime\n      0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal\n      0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized\n      0x829a: 'ExposureTime', // Exposure time (in seconds)\n      0x829d: 'FNumber',\n      0x8822: 'ExposureProgram', // Exposure program\n      0x8824: 'SpectralSensitivity', // Spectral sensitivity\n      0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2\n      0x8828: 'OECF', // Optoelectric conversion factor\n      0x8830: 'SensitivityType',\n      0x8831: 'StandardOutputSensitivity',\n      0x8832: 'RecommendedExposureIndex',\n      0x8833: 'ISOSpeed',\n      0x8834: 'ISOSpeedLatitudeyyy',\n      0x8835: 'ISOSpeedLatitudezzz',\n      0x9201: 'ShutterSpeedValue', // Shutter speed\n      0x9202: 'ApertureValue', // Lens aperture\n      0x9203: 'BrightnessValue', // Value of brightness\n      0x9204: 'ExposureBias', // Exposure bias\n      0x9205: 'MaxApertureValue', // Smallest F number of lens\n      0x9206: 'SubjectDistance', // Distance to subject in meters\n      0x9207: 'MeteringMode', // Metering mode\n      0x9208: 'LightSource', // Kind of light source\n      0x9209: 'Flash', // Flash status\n      0x9214: 'SubjectArea', // Location and area of main subject\n      0x920a: 'FocalLength', // Focal length of the lens in mm\n      0xa20b: 'FlashEnergy', // Strobe energy in BCPS\n      0xa20c: 'SpatialFrequencyResponse',\n      0xa20e: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit\n      0xa20f: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit\n      0xa210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution\n      0xa214: 'SubjectLocation', // Location of subject in image\n      0xa215: 'ExposureIndex', // Exposure index selected on camera\n      0xa217: 'SensingMethod', // Image sensor type\n      0xa300: 'FileSource', // Image source (3 == DSC)\n      0xa301: 'SceneType', // Scene type (1 == directly photographed)\n      0xa302: 'CFAPattern', // Color filter array geometric pattern\n      0xa401: 'CustomRendered', // Special processing\n      0xa402: 'ExposureMode', // Exposure mode\n      0xa403: 'WhiteBalance', // 1 = auto white balance, 2 = manual\n      0xa404: 'DigitalZoomRatio', // Digital zoom ratio\n      0xa405: 'FocalLengthIn35mmFilm',\n      0xa406: 'SceneCaptureType', // Type of scene\n      0xa407: 'GainControl', // Degree of overall image gain adjustment\n      0xa408: 'Contrast', // Direction of contrast processing applied by camera\n      0xa409: 'Saturation', // Direction of saturation processing applied by camera\n      0xa40a: 'Sharpness', // Direction of sharpness processing applied by camera\n      0xa40b: 'DeviceSettingDescription',\n      0xa40c: 'SubjectDistanceRange', // Distance to subject\n      0xa420: 'ImageUniqueID', // Identifier assigned uniquely to each image\n      0xa430: 'CameraOwnerName',\n      0xa431: 'BodySerialNumber',\n      0xa432: 'LensSpecification',\n      0xa433: 'LensMake',\n      0xa434: 'LensModel',\n      0xa435: 'LensSerialNumber'\n    },\n    0x8825: {\n      // GPSInfoIFDPointer\n      0x0000: 'GPSVersionID',\n      0x0001: 'GPSLatitudeRef',\n      0x0002: 'GPSLatitude',\n      0x0003: 'GPSLongitudeRef',\n      0x0004: 'GPSLongitude',\n      0x0005: 'GPSAltitudeRef',\n      0x0006: 'GPSAltitude',\n      0x0007: 'GPSTimeStamp',\n      0x0008: 'GPSSatellites',\n      0x0009: 'GPSStatus',\n      0x000a: 'GPSMeasureMode',\n      0x000b: 'GPSDOP',\n      0x000c: 'GPSSpeedRef',\n      0x000d: 'GPSSpeed',\n      0x000e: 'GPSTrackRef',\n      0x000f: 'GPSTrack',\n      0x0010: 'GPSImgDirectionRef',\n      0x0011: 'GPSImgDirection',\n      0x0012: 'GPSMapDatum',\n      0x0013: 'GPSDestLatitudeRef',\n      0x0014: 'GPSDestLatitude',\n      0x0015: 'GPSDestLongitudeRef',\n      0x0016: 'GPSDestLongitude',\n      0x0017: 'GPSDestBearingRef',\n      0x0018: 'GPSDestBearing',\n      0x0019: 'GPSDestDistanceRef',\n      0x001a: 'GPSDestDistance',\n      0x001b: 'GPSProcessingMethod',\n      0x001c: 'GPSAreaInformation',\n      0x001d: 'GPSDateStamp',\n      0x001e: 'GPSDifferential',\n      0x001f: 'GPSHPositioningError'\n    },\n    0xa005: {\n      // InteroperabilityIFDPointer\n      0x0001: 'InteroperabilityIndex'\n    }\n  }\n\n  // IFD1 directory can contain any IFD0 tags:\n  ExifMapProto.tags.ifd1 = ExifMapProto.tags\n\n  ExifMapProto.stringValues = {\n    ExposureProgram: {\n      0: 'Undefined',\n      1: 'Manual',\n      2: 'Normal program',\n      3: 'Aperture priority',\n      4: 'Shutter priority',\n      5: 'Creative program',\n      6: 'Action program',\n      7: 'Portrait mode',\n      8: 'Landscape mode'\n    },\n    MeteringMode: {\n      0: 'Unknown',\n      1: 'Average',\n      2: 'CenterWeightedAverage',\n      3: 'Spot',\n      4: 'MultiSpot',\n      5: 'Pattern',\n      6: 'Partial',\n      255: 'Other'\n    },\n    LightSource: {\n      0: 'Unknown',\n      1: 'Daylight',\n      2: 'Fluorescent',\n      3: 'Tungsten (incandescent light)',\n      4: 'Flash',\n      9: 'Fine weather',\n      10: 'Cloudy weather',\n      11: 'Shade',\n      12: 'Daylight fluorescent (D 5700 - 7100K)',\n      13: 'Day white fluorescent (N 4600 - 5400K)',\n      14: 'Cool white fluorescent (W 3900 - 4500K)',\n      15: 'White fluorescent (WW 3200 - 3700K)',\n      17: 'Standard light A',\n      18: 'Standard light B',\n      19: 'Standard light C',\n      20: 'D55',\n      21: 'D65',\n      22: 'D75',\n      23: 'D50',\n      24: 'ISO studio tungsten',\n      255: 'Other'\n    },\n    Flash: {\n      0x0000: 'Flash did not fire',\n      0x0001: 'Flash fired',\n      0x0005: 'Strobe return light not detected',\n      0x0007: 'Strobe return light detected',\n      0x0009: 'Flash fired, compulsory flash mode',\n      0x000d: 'Flash fired, compulsory flash mode, return light not detected',\n      0x000f: 'Flash fired, compulsory flash mode, return light detected',\n      0x0010: 'Flash did not fire, compulsory flash mode',\n      0x0018: 'Flash did not fire, auto mode',\n      0x0019: 'Flash fired, auto mode',\n      0x001d: 'Flash fired, auto mode, return light not detected',\n      0x001f: 'Flash fired, auto mode, return light detected',\n      0x0020: 'No flash function',\n      0x0041: 'Flash fired, red-eye reduction mode',\n      0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n      0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n      0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n      0x004d:\n        'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n      0x004f:\n        'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n      0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n      0x005d:\n        'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n      0x005f:\n        'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    SensingMethod: {\n      1: 'Undefined',\n      2: 'One-chip color area sensor',\n      3: 'Two-chip color area sensor',\n      4: 'Three-chip color area sensor',\n      5: 'Color sequential area sensor',\n      7: 'Trilinear sensor',\n      8: 'Color sequential linear sensor'\n    },\n    SceneCaptureType: {\n      0: 'Standard',\n      1: 'Landscape',\n      2: 'Portrait',\n      3: 'Night scene'\n    },\n    SceneType: {\n      1: 'Directly photographed'\n    },\n    CustomRendered: {\n      0: 'Normal process',\n      1: 'Custom process'\n    },\n    WhiteBalance: {\n      0: 'Auto white balance',\n      1: 'Manual white balance'\n    },\n    GainControl: {\n      0: 'None',\n      1: 'Low gain up',\n      2: 'High gain up',\n      3: 'Low gain down',\n      4: 'High gain down'\n    },\n    Contrast: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    Saturation: {\n      0: 'Normal',\n      1: 'Low saturation',\n      2: 'High saturation'\n    },\n    Sharpness: {\n      0: 'Normal',\n      1: 'Soft',\n      2: 'Hard'\n    },\n    SubjectDistanceRange: {\n      0: 'Unknown',\n      1: 'Macro',\n      2: 'Close view',\n      3: 'Distant view'\n    },\n    FileSource: {\n      3: 'DSC'\n    },\n    ComponentsConfiguration: {\n      0: '',\n      1: 'Y',\n      2: 'Cb',\n      3: 'Cr',\n      4: 'R',\n      5: 'G',\n      6: 'B'\n    },\n    Orientation: {\n      1: 'Original',\n      2: 'Horizontal flip',\n      3: 'Rotate 180¬∞ CCW',\n      4: 'Vertical flip',\n      5: 'Vertical flip + Rotate 90¬∞ CW',\n      6: 'Rotate 90¬∞ CW',\n      7: 'Horizontal flip + Rotate 90¬∞ CW',\n      8: 'Rotate 90¬∞ CCW'\n    }\n  }\n\n  ExifMapProto.getText = function (name) {\n    var value = this.get(name)\n    switch (name) {\n      case 'LightSource':\n      case 'Flash':\n      case 'MeteringMode':\n      case 'ExposureProgram':\n      case 'SensingMethod':\n      case 'SceneCaptureType':\n      case 'SceneType':\n      case 'CustomRendered':\n      case 'WhiteBalance':\n      case 'GainControl':\n      case 'Contrast':\n      case 'Saturation':\n      case 'Sharpness':\n      case 'SubjectDistanceRange':\n      case 'FileSource':\n      case 'Orientation':\n        return this.stringValues[name][value]\n      case 'ExifVersion':\n      case 'FlashpixVersion':\n        if (!value) return\n        return String.fromCharCode(value[0], value[1], value[2], value[3])\n      case 'ComponentsConfiguration':\n        if (!value) return\n        return (\n          this.stringValues[name][value[0]] +\n          this.stringValues[name][value[1]] +\n          this.stringValues[name][value[2]] +\n          this.stringValues[name][value[3]]\n        )\n      case 'GPSVersionID':\n        if (!value) return\n        return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3]\n    }\n    return String(value)\n  }\n\n  ExifMapProto.getAll = function () {\n    var map = {}\n    var prop\n    var obj\n    var name\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        obj = this[prop]\n        if (obj && obj.getAll) {\n          map[this.ifds[prop].name] = obj.getAll()\n        } else {\n          name = this.tags[prop]\n          if (name) map[name] = this.getText(name)\n        }\n      }\n    }\n    return map\n  }\n\n  ExifMapProto.getName = function (tagCode) {\n    var name = this.tags[tagCode]\n    if (typeof name === 'object') return this.ifds[tagCode].name\n    return name\n  }\n\n  // Extend the map of tag names to tag codes:\n  ;(function () {\n    var tags = ExifMapProto.tags\n    var prop\n    var ifd\n    var subTags\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        ifd = ExifMapProto.ifds[prop]\n        if (ifd) {\n          subTags = tags[prop]\n          for (prop in subTags) {\n            if (Object.prototype.hasOwnProperty.call(subTags, prop)) {\n              ifd.map[subTags[prop]] = Number(prop)\n            }\n          }\n        } else {\n          ExifMapProto.map[tags[prop]] = Number(prop)\n        }\n      }\n    }\n  })()\n})\n","/*\n * JavaScript Load Image IPTC Parser\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-meta'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-meta'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  /**\n   * IPTC tag map\n   *\n   * @name IptcMap\n   * @class\n   */\n  function IptcMap() {}\n\n  IptcMap.prototype.map = {\n    ObjectName: 5\n  }\n\n  IptcMap.prototype.types = {\n    0: 'Uint16', // ApplicationRecordVersion\n    200: 'Uint16', // ObjectPreviewFileFormat\n    201: 'Uint16', // ObjectPreviewFileVersion\n    202: 'binary' // ObjectPreviewData\n  }\n\n  /**\n   * Retrieves IPTC tag value\n   *\n   * @param {number|string} id IPTC tag code or name\n   * @returns {object} IPTC tag value\n   */\n  IptcMap.prototype.get = function (id) {\n    return this[id] || this[this.map[id]]\n  }\n\n  /**\n   * Retrieves string for the given DataView and range\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Offset start\n   * @param {number} length Offset length\n   * @returns {string} String value\n   */\n  function getStringValue(dataView, offset, length) {\n    var outstr = ''\n    var end = offset + length\n    for (var n = offset; n < end; n += 1) {\n      outstr += String.fromCharCode(dataView.getUint8(n))\n    }\n    return outstr\n  }\n\n  /**\n   * Retrieves tag value for the given DataView and range\n   *\n   * @param {number} tagCode tag code\n   * @param {IptcMap} map IPTC tag map\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Range start\n   * @param {number} length Range length\n   * @returns {object} Tag value\n   */\n  function getTagValue(tagCode, map, dataView, offset, length) {\n    if (map.types[tagCode] === 'binary') {\n      return new Blob([dataView.buffer.slice(offset, offset + length)])\n    }\n    if (map.types[tagCode] === 'Uint16') {\n      return dataView.getUint16(offset)\n    }\n    return getStringValue(dataView, offset, length)\n  }\n\n  /**\n   * Combines IPTC value with existing ones.\n   *\n   * @param {object} value Existing IPTC field value\n   * @param {object} newValue New IPTC field value\n   * @returns {object} Resulting IPTC field value\n   */\n  function combineTagValues(value, newValue) {\n    if (value === undefined) return newValue\n    if (value instanceof Array) {\n      value.push(newValue)\n      return value\n    }\n    return [value, newValue]\n  }\n\n  /**\n   * Parses IPTC tags.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} segmentOffset Segment offset\n   * @param {number} segmentLength Segment length\n   * @param {object} data Data export object\n   * @param {object} includeTags Map of tags to include\n   * @param {object} excludeTags Map of tags to exclude\n   */\n  function parseIptcTags(\n    dataView,\n    segmentOffset,\n    segmentLength,\n    data,\n    includeTags,\n    excludeTags\n  ) {\n    var value, tagSize, tagCode\n    var segmentEnd = segmentOffset + segmentLength\n    var offset = segmentOffset\n    while (offset < segmentEnd) {\n      if (\n        dataView.getUint8(offset) === 0x1c && // tag marker\n        dataView.getUint8(offset + 1) === 0x02 // record number, only handles v2\n      ) {\n        tagCode = dataView.getUint8(offset + 2)\n        if (\n          (!includeTags || includeTags[tagCode]) &&\n          (!excludeTags || !excludeTags[tagCode])\n        ) {\n          tagSize = dataView.getInt16(offset + 3)\n          value = getTagValue(tagCode, data.iptc, dataView, offset + 5, tagSize)\n          data.iptc[tagCode] = combineTagValues(data.iptc[tagCode], value)\n          if (data.iptcOffsets) {\n            data.iptcOffsets[tagCode] = offset\n          }\n        }\n      }\n      offset += 1\n    }\n  }\n\n  /**\n   * Tests if field segment starts at offset.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Segment offset\n   * @returns {boolean} True if '8BIM<EOT><EOT>' exists at offset\n   */\n  function isSegmentStart(dataView, offset) {\n    return (\n      dataView.getUint32(offset) === 0x3842494d && // Photoshop segment start\n      dataView.getUint16(offset + 4) === 0x0404 // IPTC segment start\n    )\n  }\n\n  /**\n   * Returns header length.\n   *\n   * @param {DataView} dataView Data view interface\n   * @param {number} offset Segment offset\n   * @returns {number} Header length\n   */\n  function getHeaderLength(dataView, offset) {\n    var length = dataView.getUint8(offset + 7)\n    if (length % 2 !== 0) length += 1\n    // Check for pre photoshop 6 format\n    if (length === 0) {\n      // Always 4\n      length = 4\n    }\n    return length\n  }\n\n  loadImage.parseIptcData = function (dataView, offset, length, data, options) {\n    if (options.disableIptc) {\n      return\n    }\n    var markerLength = offset + length\n    while (offset + 8 < markerLength) {\n      if (isSegmentStart(dataView, offset)) {\n        var headerLength = getHeaderLength(dataView, offset)\n        var segmentOffset = offset + 8 + headerLength\n        if (segmentOffset > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment offset.')\n          break\n        }\n        var segmentLength = dataView.getUint16(offset + 6 + headerLength)\n        if (offset + segmentLength > markerLength) {\n          // eslint-disable-next-line no-console\n          console.log('Invalid IPTC data: Invalid segment size.')\n          break\n        }\n        // Create the iptc object to store the tags:\n        data.iptc = new IptcMap()\n        if (!options.disableIptcOffsets) {\n          data.iptcOffsets = new IptcMap()\n        }\n        parseIptcTags(\n          dataView,\n          segmentOffset,\n          segmentLength,\n          data,\n          options.includeIptcTags,\n          options.excludeIptcTags || { 202: true } // ObjectPreviewData\n        )\n        return\n      }\n      // eslint-disable-next-line no-param-reassign\n      offset += 1\n    }\n  }\n\n  // Registers this IPTC parser for the APP13 JPEG metadata segment:\n  loadImage.metaDataParsers.jpeg[0xffed].push(loadImage.parseIptcData)\n\n  loadImage.IptcMap = IptcMap\n\n  // Adds the following properties to the parseMetaData callback data:\n  // - iptc: The iptc tags, parsed by the parseIptcData method\n\n  // Adds the following options to the parseMetaData method:\n  // - disableIptc: Disables IPTC parsing when true.\n  // - disableIptcOffsets: Disables storing IPTC tag offsets when true.\n  // - includeIptcTags: A map of IPTC tags to include for parsing.\n  // - excludeIptcTags: A map of IPTC tags to exclude from parsing.\n})\n","/*\n * JavaScript Load Image IPTC Map\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * Copyright 2018, Dave Bevan\n *\n * IPTC tags mapping based on\n * https://iptc.org/standards/photo-metadata\n * https://exiftool.org/TagNames/IPTC.html\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image', './load-image-iptc'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'), require('./load-image-iptc'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var IptcMapProto = loadImage.IptcMap.prototype\n\n  IptcMapProto.tags = {\n    0: 'ApplicationRecordVersion',\n    3: 'ObjectTypeReference',\n    4: 'ObjectAttributeReference',\n    5: 'ObjectName',\n    7: 'EditStatus',\n    8: 'EditorialUpdate',\n    10: 'Urgency',\n    12: 'SubjectReference',\n    15: 'Category',\n    20: 'SupplementalCategories',\n    22: 'FixtureIdentifier',\n    25: 'Keywords',\n    26: 'ContentLocationCode',\n    27: 'ContentLocationName',\n    30: 'ReleaseDate',\n    35: 'ReleaseTime',\n    37: 'ExpirationDate',\n    38: 'ExpirationTime',\n    40: 'SpecialInstructions',\n    42: 'ActionAdvised',\n    45: 'ReferenceService',\n    47: 'ReferenceDate',\n    50: 'ReferenceNumber',\n    55: 'DateCreated',\n    60: 'TimeCreated',\n    62: 'DigitalCreationDate',\n    63: 'DigitalCreationTime',\n    65: 'OriginatingProgram',\n    70: 'ProgramVersion',\n    75: 'ObjectCycle',\n    80: 'Byline',\n    85: 'BylineTitle',\n    90: 'City',\n    92: 'Sublocation',\n    95: 'State',\n    100: 'CountryCode',\n    101: 'Country',\n    103: 'OriginalTransmissionReference',\n    105: 'Headline',\n    110: 'Credit',\n    115: 'Source',\n    116: 'CopyrightNotice',\n    118: 'Contact',\n    120: 'Caption',\n    121: 'LocalCaption',\n    122: 'Writer',\n    125: 'RasterizedCaption',\n    130: 'ImageType',\n    131: 'ImageOrientation',\n    135: 'LanguageIdentifier',\n    150: 'AudioType',\n    151: 'AudioSamplingRate',\n    152: 'AudioSamplingResolution',\n    153: 'AudioDuration',\n    154: 'AudioOutcue',\n    184: 'JobID',\n    185: 'MasterDocumentID',\n    186: 'ShortDocumentID',\n    187: 'UniqueDocumentID',\n    188: 'OwnerID',\n    200: 'ObjectPreviewFileFormat',\n    201: 'ObjectPreviewFileVersion',\n    202: 'ObjectPreviewData',\n    221: 'Prefs',\n    225: 'ClassifyState',\n    228: 'SimilarityIndex',\n    230: 'DocumentNotes',\n    231: 'DocumentHistory',\n    232: 'ExifCameraInfo',\n    255: 'CatalogSets'\n  }\n\n  IptcMapProto.stringValues = {\n    10: {\n      0: '0 (reserved)',\n      1: '1 (most urgent)',\n      2: '2',\n      3: '3',\n      4: '4',\n      5: '5 (normal urgency)',\n      6: '6',\n      7: '7',\n      8: '8 (least urgent)',\n      9: '9 (user-defined priority)'\n    },\n    75: {\n      a: 'Morning',\n      b: 'Both Morning and Evening',\n      p: 'Evening'\n    },\n    131: {\n      L: 'Landscape',\n      P: 'Portrait',\n      S: 'Square'\n    }\n  }\n\n  IptcMapProto.getText = function (id) {\n    var value = this.get(id)\n    var tagCode = this.map[id]\n    var stringValue = this.stringValues[tagCode]\n    if (stringValue) return stringValue[value]\n    return String(value)\n  }\n\n  IptcMapProto.getAll = function () {\n    var map = {}\n    var prop\n    var name\n    for (prop in this) {\n      if (Object.prototype.hasOwnProperty.call(this, prop)) {\n        name = this.tags[prop]\n        if (name) map[name] = this.getText(name)\n      }\n    }\n    return map\n  }\n\n  IptcMapProto.getName = function (tagCode) {\n    return this.tags[tagCode]\n  }\n\n  // Extend the map of tag names to tag codes:\n  ;(function () {\n    var tags = IptcMapProto.tags\n    var map = IptcMapProto.map || {}\n    var prop\n    // Map the tag names to tags:\n    for (prop in tags) {\n      if (Object.prototype.hasOwnProperty.call(tags, prop)) {\n        map[tags[prop]] = Number(prop)\n      }\n    }\n  })()\n})\n"]}